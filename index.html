<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>WebXR RTI Dome (v2 with Debugging)</title>
    <style>
        body { 
            margin: 0; 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; 
            overflow: hidden; 
            background-color: #000; 
            color: #fff; 
            overscroll-behavior: none;
        }
        #inputContainer {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(20,20,20,0.85);
            padding: 15px;
            border-radius: 12px;
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 12px;
            max-width: calc(100% - 40px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.1);
        }
        #inputContainer label, #settingsModal label {
            font-size: 0.9em;
            color: #ccc;
            margin-bottom: 3px;
            display: block;
        }
        #inputContainer input[type="number"], 
        #inputContainer input[type="text"],
        #settingsModal input[type="number"], 
        #settingsModal input[type="text"] {
            width: calc(100% - 18px); 
            padding: 10px; 
            border-radius: 6px; 
            border: 1px solid #444; 
            background: #2a2a2a;
            color: #fff;
            font-size: 0.95em;
            box-sizing: border-box;
            margin-bottom: 8px;
        }
        #inputContainer input:focus, #settingsModal input:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 2px rgba(0,123,255,0.25);
        }
        #inputContainer button, #arModeControls button, #settingsModal button {
            padding: 12px 15px; 
            background-color: #007bff; 
            color: white;
            border: none; 
            border-radius: 6px; 
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.2s ease;
        }
        #inputContainer button:hover, #arModeControls button:hover, #settingsModal button:hover {
            background-color: #0056b3;
        }
        #arButton {
            position: absolute !important; 
            bottom: 20px !important;
            left: 50% !important;
            transform: translateX(-50%) !important;
            padding: 12px 20px !important;
            background-color: #28a745 !important;
            color: white !important;
            border: none !important;
            border-radius: 8px !important;
            font-size: 1.1em !important;
            z-index: 100 !important;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3) !important;
        }
        #statusMessage {
            position: absolute;
            bottom: 80px; 
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.75);
            padding: 10px 15px;
            border-radius: 8px;
            color: white;
            z-index: 10;
            text-align: center;
            font-size: 0.9em;
            display: none; 
            max-width: 80%;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        #arModeControls {
            display: none; /* Initially hidden */
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 20;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        #arModeControls button {
            background-color: #17a2b8; /* Teal color for AR controls */
            font-size: 0.9em;
        }
        #arModeControls button:hover {
            background-color: #117a8b;
        }
        #settingsModal {
            display: none; /* Initially hidden */
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            background: rgba(30,30,30,0.97);
            padding: 25px;
            border-radius: 15px;
            z-index: 101; /* Higher than AR button */
            width: 90%;
            max-width: 380px;
            box-shadow: 0 8px 30px rgba(0,0,0,0.6);
            border: 1px solid rgba(255,255,255,0.15);
        }
        #settingsModal h3 {
            margin-top: 0;
            margin-bottom: 20px;
            color: #00aeff;
            text-align: center;
            font-size: 1.3em;
        }
        #settingsModal .modal-actions {
            display: flex;
            justify-content: space-around;
            margin-top: 25px;
        }
         #settingsModal .modal-actions button {
            width: 45%;
         }
         #settingsModal #applyModalSettingsButton {
            background-color: #28a745; /* Green for apply */
         }
         #settingsModal #applyModalSettingsButton:hover {
            background-color: #1e7e34; 
         }
         #settingsModal #closeModalButton {
            background-color: #dc3545; /* Red for close */
         }
         #settingsModal #closeModalButton:hover {
            background-color: #b02a37;
         }
    </style>
</head>
<body>
    <div id="inputContainer">
        <div>
            <label for="targetSize">대상 실제 크기 (mm):</label>
            <input type="number" id="targetSize" value="100">
        </div>
        <div>
            <label for="radiusMultiplier">돔 반지름 배율 (대상 크기의 N배, 2-4):</label>
            <input type="number" id="radiusMultiplier" value="3" min="2" max="4" step="0.1">
        </div>
        <div>
            <label for="azimuths">방위각 리스트 (°): (예: 0,45,90)</label>
            <input type="text" id="azimuths" value="0,45,90,135,180,225,270,315">
        </div>
        <div>
            <label for="elevations">고도각 리스트 (°): (예: 15,30,45)</label>
            <input type="text" id="elevations" value="15,30,45,60,75">
        </div>
        <button id="generateDomeButton">돔 생성/업데이트 (AR 시작 후)</button>
    </div>

    <div id="arModeControls">
        <button id="arSettingsButton">입력값</button>
        <button id="torchButton">손전등 켜기</button>
    </div>

    <div id="settingsModal">
        <h3>AR 설정</h3>
        <div>
            <label for="modalTargetSize">대상 실제 크기 (mm):</label>
            <input type="number" id="modalTargetSize">
        </div>
        <div>
            <label for="modalRadiusMultiplier">돔 반지름 배율 (2-4):</label>
            <input type="number" id="modalRadiusMultiplier" min="2" max="4" step="0.1">
        </div>
        <div>
            <label for="modalAzimuths">방위각 리스트 (°):</label>
            <input type="text" id="modalAzimuths">
        </div>
        <div>
            <label for="modalElevations">고도각 리스트 (°):</label>
            <input type="text" id="modalElevations">
        </div>
        <div class="modal-actions">
            <button id="applyModalSettingsButton">적용</button>
            <button id="closeModalButton">닫기</button>
        </div>
    </div>

    <div id="statusMessage"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { ARButton } from 'three/addons/webxr/ARButton.js';

        let camera, scene, renderer;
        let controller;
        let reticle; 
        let domeGroup = null; 
        let hitTestSource = null;
        
        let targetSize = 100; 
        let radiusMultiplier = 3;
        let azimuths = [0, 45, 90, 135, 180, 225, 270, 315];
        let elevations = [15, 30, 45, 60, 75];

        const raycaster = new THREE.Raycaster();
        const statusMessage = document.getElementById('statusMessage');
        const inputContainer = document.getElementById('inputContainer');
        const arModeControls = document.getElementById('arModeControls');
        const settingsModal = document.getElementById('settingsModal');
        const torchButton = document.getElementById('torchButton');

        let isDraggingDome = false;
        let activePointerId = null; 
        let currentStream = null;
        let isTorchOn = false;

        init();
        animate();

        function init() {
            console.log("Initializing application...");
            scene = new THREE.Scene();
            scene.add(new THREE.AmbientLight(0x888888,1));
            const directionalLight = new THREE.DirectionalLight(0xffffff, 2.5);
            directionalLight.position.set(0.5, 1, 0.75).normalize();
            scene.add(directionalLight);

            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 40);

            reticle = new THREE.Mesh(
                new THREE.RingGeometry(0.03, 0.04, 32).rotateX(-Math.PI / 2),
                new THREE.MeshBasicMaterial({ color: 0xffffff, opacity: 0.9, transparent: true, depthTest: false, side: THREE.DoubleSide })
            );
            reticle.matrixAutoUpdate = false;
            reticle.visible = false;
            scene.add(reticle);
            console.log("Reticle created and added to scene.");

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);
            console.log("Renderer initialized.");

            const arButtonElement = ARButton.createButton(renderer, {
                requiredFeatures: ['hit-test', 'dom-overlay'],
                optionalFeatures: ['anchors', 'plane-detection'],
                domOverlay: { root: document.body } 
            });
            document.body.appendChild(arButtonElement);
            arButtonElement.id = 'arButton';
            arButtonElement.style.display = 'block';
            console.log("ARButton created.");

            controller = renderer.xr.getController(0);
            controller.addEventListener('selectstart', onSelectStart);
            scene.add(controller);
            console.log("Controller initialized and 'selectstart' listener added.");

            // Input listeners
            document.getElementById('targetSize').addEventListener('input', (e) => targetSize = parseFloat(e.target.value) || 100);
            document.getElementById('radiusMultiplier').addEventListener('input', (e) => radiusMultiplier = parseFloat(e.target.value) || 3);
            document.getElementById('azimuths').addEventListener('input', (e) => azimuths = e.target.value.split(',').map(Number).filter(n => !isNaN(n)));
            document.getElementById('elevations').addEventListener('input', (e) => elevations = e.target.value.split(',').map(Number).filter(n => !isNaN(n)));
            
            document.getElementById('generateDomeButton').addEventListener('click', () => {
                if (!renderer.xr.isPresenting) {
                    showStatus("AR 세션을 먼저 시작해주세요.", 3000);
                    return;
                }
                updateAndPlaceDome();
            });

            document.getElementById('arSettingsButton').addEventListener('click', openSettingsModal);
            torchButton.addEventListener('click', toggleTorch);
            document.getElementById('applyModalSettingsButton').addEventListener('click', applySettingsFromModal);
            document.getElementById('closeModalButton').addEventListener('click', closeSettingsModal);
            
            // Initialize from HTML defaults
            targetSize = parseFloat(document.getElementById('targetSize').value);
            radiusMultiplier = parseFloat(document.getElementById('radiusMultiplier').value);
            azimuths = document.getElementById('azimuths').value.split(',').map(Number).filter(n => !isNaN(n));
            elevations = document.getElementById('elevations').value.split(',').map(Number).filter(n => !isNaN(n));
            console.log("Initial parameters set from HTML.");

            // Pointer events for dome dragging
            renderer.domElement.addEventListener('pointerdown', onPointerDown, false);
            renderer.domElement.addEventListener('pointermove', onPointerMove, false);
            renderer.domElement.addEventListener('pointerup', onPointerUp, false);
            renderer.domElement.addEventListener('pointercancel', onPointerUp, false);
            
            window.addEventListener('resize', onWindowResize);

            // Handle XR session start/end
            renderer.xr.addEventListener('sessionstart', async () => {
                console.log("XR session started.");
                const session = renderer.xr.getSession();
                showStatus("AR 세션 시작됨. 표면을 찾아 레티클을 조준하고 탭하여 돔 배치.", 0);
                inputContainer.style.display = 'none';
                arModeControls.style.display = 'flex';

                try {
                    const viewerReferenceSpace = await session.requestReferenceSpace('viewer');
                    console.log("Viewer reference space acquired.");
                    hitTestSource = await session.requestHitTestSource({ space: viewerReferenceSpace });
                    if (hitTestSource) {
                        console.log("Hit-test source acquired successfully.");
                    } else {
                        showStatus("표면 감지 기능(Hit-test)을 시작할 수 없습니다.", 4000);
                        console.warn("Hit-test source was not acquired (returned null or undefined).");
                    }
                } catch (error) {
                    console.error("Hit-test source 요청 실패:", error);
                    showStatus("Hit-test를 시작할 수 없습니다. AR 기능이 제한될 수 있습니다.", 4000);
                }
                
                try {
                    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                        const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } });
                        currentStream = stream;
                        console.log("Camera stream for torch acquired.");
                    }
                } catch (err) {
                    console.warn("카메라 접근 실패 (손전등용):", err);
                }
            });

            renderer.xr.addEventListener('sessionend', () => {
                console.log("XR session ended.");
                hitTestSource = null;
                reticle.visible = false;
                clearDomeAndChildren();
                showStatus("AR 세션 종료됨.", 3000);
                inputContainer.style.display = 'flex';
                arModeControls.style.display = 'none';
                closeSettingsModal();
                
                if (isTorchOn) {
                    controlTorch(false); 
                } else if (currentStream) { 
                    currentStream.getTracks().forEach(track => {
                        if (track.readyState === 'live') track.stop();
                    });
                    currentStream = null;
                    console.log("Camera stream released on session end (torch was not active).");
                }
                isTorchOn = false;
                torchButton.textContent = "손전등 켜기";
            });
            showStatus("AR 세션을 시작하고, 바닥이나 벽을 탭하여 돔을 배치하세요.", 5000);
            console.log("Initialization complete.");
        }
        
        function updateAndPlaceDome(hitMatrix = null) {
            console.log("updateAndPlaceDome called.");
            if (hitMatrix) console.log("hitMatrix provided."); else console.log("No hitMatrix provided (updating existing dome).");

            const tempWorldPos = new THREE.Vector3(); 

            if (domeGroup && domeGroup.userData.anchor && !hitMatrix) {
                const existingAnchor = domeGroup.userData.anchor;
                clearDomeAndChildren();
                domeGroup = createDome();
                domeGroup.userData.anchor = existingAnchor;
                scene.add(domeGroup);
                showStatus("돔 설정 업데이트 완료.", 2000);
                console.log("Existing anchored dome updated.");
            } else if (domeGroup && !domeGroup.userData.anchor && !hitMatrix) {
                const oldPosition = domeGroup.position.clone();
                const oldQuaternion = domeGroup.quaternion.clone();
                clearDomeAndChildren();
                domeGroup = createDome();
                domeGroup.position.copy(oldPosition);
                domeGroup.quaternion.copy(oldQuaternion);
                scene.add(domeGroup);
                showStatus("돔 설정 업데이트 완료. (앵커 없음)", 2000);
                console.log("Existing non-anchored dome updated.");
            } else if (hitMatrix) {
                clearDomeAndChildren();
                domeGroup = createDome();
                const domeRadiusVal = domeGroup.children[0]?.geometry.parameters.radius.toFixed(3) || "N/A";

                const session = renderer.xr.getSession();
                const frame = renderer.xr.getFrame();
                const referenceSpace = renderer.xr.getReferenceSpace();

                if (session && frame && referenceSpace && hitMatrix.userData?.hitTestResult) {
                    console.log("Attempting to create anchor for new dome.");
                    const hit = hitMatrix.userData.hitTestResult;
                    hit.createAnchor().then(anchor => {
                        domeGroup.userData.anchor = anchor;
                        scene.add(domeGroup);
                        
                        const anchorPose = frame.getPose(anchor.anchorSpace, referenceSpace);
                        if (anchorPose) {
                            const anchorMatrix = new THREE.Matrix4().fromArray(anchorPose.transform.matrix);
                            anchorMatrix.decompose(tempWorldPos, new THREE.Quaternion(), new THREE.Vector3());
                            console.log(`Dome ANCHORED. World Pos (approx): ${tempWorldPos.x.toFixed(2)},${tempWorldPos.y.toFixed(2)},${tempWorldPos.z.toFixed(2)}. Visible: ${domeGroup.visible}. Radius: ${domeRadiusVal}`);
                        } else {
                            console.log(`Dome ANCHORED but initial pose not available for logging. Visible: ${domeGroup.visible}. Radius: ${domeRadiusVal}`);
                        }
                        reticle.visible = false;
                        showStatus("돔 배치 완료 (앵커 사용).", 3000);
                    }).catch(err => {
                        console.warn("앵커 생성 실패:", err);
                        domeGroup.applyMatrix4(hitMatrix);
                        scene.add(domeGroup);
                        domeGroup.getWorldPosition(tempWorldPos);
                        console.log(`Dome MATRIX-PLACED (anchor failed). World Pos: ${tempWorldPos.x.toFixed(2)},${tempWorldPos.y.toFixed(2)},${tempWorldPos.z.toFixed(2)}. Visible: ${domeGroup.visible}. Radius: ${domeRadiusVal}`);
                        reticle.visible = true; 
                        showStatus("돔 배치 완료 (앵커 실패, 직접 배치).", 3000);
                    });
                } else { 
                    domeGroup.applyMatrix4(hitMatrix);
                    scene.add(domeGroup);
                    domeGroup.getWorldPosition(tempWorldPos);
                    console.log(`Dome MATRIX-PLACED (no anchor info). World Pos: ${tempWorldPos.x.toFixed(2)},${tempWorldPos.y.toFixed(2)},${tempWorldPos.z.toFixed(2)}. Visible: ${domeGroup.visible}. Radius: ${domeRadiusVal}`);
                    reticle.visible = true; 
                    showStatus("돔 배치 완료 (앵커 정보 없음).", 3000);
                }
            } else {
                 showStatus("돔을 먼저 배치하세요. 레티클을 바닥/벽에 조준하고 탭하세요.", 3000);
                 console.log("updateAndPlaceDome: No dome to update and no hitMatrix to place new one.");
            }
        }

        function showStatus(message, duration = 3000) {
            statusMessage.textContent = message;
            statusMessage.style.display = 'block';
            if (statusMessage.timeoutId) clearTimeout(statusMessage.timeoutId);
            if (duration > 0) {
                statusMessage.timeoutId = setTimeout(() => {
                    statusMessage.style.display = 'none';
                }, duration);
            }
        }
        
        function clearDomeAndChildren() {
            if (!domeGroup) return;
            console.log("Clearing previous dome...");
            domeGroup.traverse(child => {
                if (child.isMesh) {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(m => { if (m.map) m.map.dispose(); m.dispose(); });
                        } else {
                            if (child.material.map) child.material.map.dispose(); child.material.dispose();
                        }
                    }
                }
                if (child.isSprite && child.material) {
                     if (child.material.map) child.material.map.dispose(); child.material.dispose();
                }
            });
            scene.remove(domeGroup);
            domeGroup.userData.anchor = null; 
            domeGroup = null;
            console.log("Previous dome cleared.");
        }

        function createDome() {
            const newDomeGroup = new THREE.Group();
            const actualRadius = Math.max(0.01, (targetSize * radiusMultiplier) / 1000); 

            const domeGeometry = new THREE.SphereGeometry(actualRadius, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2);
            const domeMaterial = new THREE.MeshStandardMaterial({
                color: 0x101010, transparent: true, opacity: 0.65, side: THREE.DoubleSide,
                metalness: 0.1, roughness: 0.9,
            });
            const hemisphere = new THREE.Mesh(domeGeometry, domeMaterial);
            hemisphere.userData.isDomePart = true; 
            newDomeGroup.add(hemisphere);

            const markerRadius = Math.max(0.003, actualRadius * 0.025); 
            const markerGeometry = new THREE.SphereGeometry(markerRadius, 12, 6);
            const markerMaterial = new THREE.MeshStandardMaterial({ color: 0xFFD700, metalness: 0.3, roughness: 0.4 });

            (elevations || []).forEach(el => {
                (azimuths || []).forEach(az => {
                    if (isNaN(el) || isNaN(az)) return;
                    const elRad = THREE.MathUtils.degToRad(el);
                    const azRad = THREE.MathUtils.degToRad(az);
                    const x = actualRadius * Math.cos(elRad) * Math.cos(azRad);
                    const y = actualRadius * Math.sin(elRad); 
                    const z = actualRadius * Math.cos(elRad) * Math.sin(azRad);

                    const marker = new THREE.Mesh(markerGeometry, markerMaterial.clone());
                    marker.position.set(x, y, z);
                    marker.userData = { isLightMarker: true, azimuth: az, elevation: el, labelMesh: null, isLabelVisible: false };
                    newDomeGroup.add(marker);
                });
            });
            newDomeGroup.userData.isDomeRoot = true;
            newDomeGroup.userData.anchor = null; 
            console.log(`Dome created with radius: ${actualRadius.toFixed(3)}m`);
            return newDomeGroup;
        }

        function onSelectStart(event) {
            console.log("onSelectStart triggered!"); // 1. 함수 호출 확인
            const session = renderer.xr.getSession();
            if (!session) {
                console.log("onSelectStart: No XR session.");
                return;
            }

            console.log(`onSelectStart: hitTestSource available? ${!!hitTestSource}, reticle visible? ${reticle.visible}`); // 2. hitTestSource 와 reticle 상태

            if (hitTestSource && reticle.visible) {
                const frame = renderer.xr.getFrame();
                if (!frame) {
                    console.warn("onSelectStart: No XRFrame available.");
                    showStatus("프레임 정보 없음. 다시 시도.", 2000);
                    return;
                }
                console.log("onSelectStart: XRFrame acquired.");

                const hitTestResults = frame.getHitTestResults(hitTestSource);
                console.log(`onSelectStart: Hit test results count: ${hitTestResults.length}`); // 3. Hit-test 결과 수

                if (hitTestResults.length > 0) {
                    const hit = hitTestResults[0];
                    const referenceSpace = renderer.xr.getReferenceSpace();
                    if (!referenceSpace) {
                        console.warn("onSelectStart: No reference space available.");
                        showStatus("기준 공간 정보 없음. 다시 시도.", 2000);
                        return;
                    }
                    console.log("onSelectStart: Reference space acquired.");

                    const hitPose = hit.getPose(referenceSpace);
                    
                    if (hitPose) {
                        console.log("onSelectStart: Hit pose acquired. Attempting to place dome."); // 4. Hit pose 획득 성공
                        const hitMatrix = new THREE.Matrix4().fromArray(hitPose.transform.matrix);
                        hitMatrix.userData = { hitTestResult: hit };
                        updateAndPlaceDome(hitMatrix);
                    } else {
                         showStatus("위치 감지 실패. 다시 시도하세요.", 2000);
                         console.warn("onSelectStart: Hit test returned a hit, but getPose failed.");
                    }
                } else {
                    showStatus("표면 감지 실패. 다른 곳을 조준하세요.", 2000);
                    console.log("onSelectStart: No hit test results at reticle position.");
                }
            } else if (domeGroup) { 
                console.log("onSelectStart: Checking for marker interaction.");
                const controller = event.target; 
                const tempMatrix = new THREE.Matrix4();
                tempMatrix.identity().extractRotation(controller.matrixWorld); 
                raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld); 
                raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix); 

                const intersects = raycaster.intersectObject(domeGroup, true);
                if (intersects.length > 0) {
                    const firstIntersected = intersects[0].object;
                    if (firstIntersected.userData.isLightMarker) {
                        toggleMarkerLabel(firstIntersected);
                    }
                }
            } else if (!hitTestSource) {
                showStatus("표면 감지 기능을 초기화 중입니다. 잠시 후 다시 시도하세요.", 2500);
                console.warn("onSelectStart: Attempted select but hitTestSource is not available.");
            } else if (!reticle.visible) {
                showStatus("레티클이 표면을 찾지 못했습니다. 다른 곳을 조준하세요.", 2500);
                console.log("onSelectStart: Reticle not visible, no target for placement.");
            }
        }
        
        function toggleMarkerLabel(marker) {
            marker.userData.isLabelVisible = !marker.userData.isLabelVisible;
            if (marker.userData.isLabelVisible) {
                if (!marker.userData.labelMesh) {
                    const labelText = `${marker.userData.azimuth}°, ${marker.userData.elevation}°`;
                    marker.userData.labelMesh = createTextSprite(labelText, { 
                        fontsize: 28, fontface: "Arial", 
                        textColor: { r:255, g:255, b:255, a:1.0 },
                        backgroundColor: { r:30, g:30, b:30, a:0.7 }
                    });
                    
                    const domeRadius = domeGroup.children.find(c => c.userData.isDomePart)?.geometry.parameters.radius || 1;
                    const labelScaleFactor = domeRadius * 0.07; 
                    marker.userData.labelMesh.scale.set(labelScaleFactor * 2, labelScaleFactor, labelScaleFactor); 

                    const offset = new THREE.Vector3(0, marker.geometry.parameters.radius * 3.5, 0);
                    marker.userData.labelMesh.position.copy(marker.position).add(offset);
                    
                    domeGroup.add(marker.userData.labelMesh); 
                }
                marker.userData.labelMesh.visible = true;
            } else {
                if (marker.userData.labelMesh) {
                    marker.userData.labelMesh.visible = false;
                }
            }
        }

        function createTextSprite(message, parameters = {}) {
            const fontface = parameters.fontface || 'Arial';
            const fontsize = parameters.fontsize || 20;
            const borderThickness = parameters.borderThickness || 0;
            const borderColor = parameters.borderColor || { r:0, g:0, b:0, a:0.0 };
            const backgroundColor = parameters.backgroundColor || { r:0, g:0, b:0, a:0.5 };
            const textColor = parameters.textColor || { r:255, g:255, b:255, a:1.0 };
            const padding = parameters.padding || 10;

            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            context.font = `Bold ${fontsize}px ${fontface}`;
            const metrics = context.measureText(message);
            const textWidth = metrics.width;
            
            canvas.width = textWidth + padding * 2 + borderThickness * 2;
            canvas.height = fontsize * 1.4 + padding * 2 + borderThickness * 2; 
            context.font = `Bold ${fontsize}px ${fontface}`; 
            
            context.fillStyle = `rgba(${backgroundColor.r},${backgroundColor.g},${backgroundColor.b},${backgroundColor.a})`;
            context.strokeStyle = `rgba(${borderColor.r},${borderColor.g},${borderColor.b},${borderColor.a})`;
            context.lineWidth = borderThickness;
            
            const radius = 8; 
            context.beginPath();
            context.moveTo(radius + borderThickness, borderThickness);
            context.lineTo(canvas.width - radius - borderThickness, borderThickness);
            context.quadraticCurveTo(canvas.width - borderThickness, borderThickness, canvas.width - borderThickness, radius + borderThickness);
            context.lineTo(canvas.width - borderThickness, canvas.height - radius - borderThickness);
            context.quadraticCurveTo(canvas.width - borderThickness, canvas.height - borderThickness, canvas.width - radius - borderThickness, canvas.height - borderThickness);
            context.lineTo(radius + borderThickness, canvas.height - borderThickness);
            context.quadraticCurveTo(borderThickness, canvas.height - borderThickness, borderThickness, canvas.height - radius - borderThickness);
            context.lineTo(borderThickness, radius + borderThickness);
            context.quadraticCurveTo(borderThickness, borderThickness, radius + borderThickness, borderThickness);
            context.closePath();
            context.fill();
            if (borderThickness > 0) context.stroke();

            context.fillStyle = `rgba(${textColor.r},${textColor.g},${textColor.b},${textColor.a})`;
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(message, canvas.width / 2, canvas.height / 2);

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture, depthTest: false });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(canvas.width / 100, canvas.height / 100, 1.0); 
            return sprite;
        }

        function onPointerDown(event) {
            if (!renderer.xr.isPresenting || !domeGroup ) return;
            if (event.pointerType === 'mouse' && event.button !== 0) return;

            const clickX = (event.clientX / window.innerWidth) * 2 - 1;
            const clickY = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera({x: clickX, y: clickY}, camera);

            const intersects = raycaster.intersectObject(domeGroup, true);
            if (intersects.length > 0) {
                const firstIntersected = intersects[0].object;
                if (firstIntersected.userData.isDomePart || domeGroup.children.includes(firstIntersected)) { 
                    isDraggingDome = true;
                    activePointerId = event.pointerId;
                    renderer.domElement.setPointerCapture(event.pointerId);
                    showStatus("돔 이동 중... 기기 중앙을 원하는 위치로 조준하며 드래그.", 0);
                    if (!domeGroup.userData.anchor) reticle.visible = true;
                }
            }
        }

        function onPointerMove(event) {
            if (!isDraggingDome || event.pointerId !== activePointerId || !renderer.xr.isPresenting) {
                return;
            }
        }

        function onPointerUp(event) {
            if (event.pointerId !== activePointerId) return;
            if (isDraggingDome) {
                isDraggingDome = false;
                activePointerId = null;
                renderer.domElement.releasePointerCapture(event.pointerId);
                
                if (domeGroup && reticle.visible && !domeGroup.userData.anchor) {
                    const frame = renderer.xr.getFrame();
                    if (frame && hitTestSource) {
                        const hitTestResults = frame.getHitTestResults(hitTestSource);
                        if (hitTestResults.length > 0) {
                            const hit = hitTestResults[0];
                            const referenceSpace = renderer.xr.getReferenceSpace();
                            const hitPose = hit.getPose(referenceSpace);
                            if (hitPose) {
                                domeGroup.position.copy(hitPose.transform.position);
                                domeGroup.quaternion.copy(hitPose.transform.orientation);
                                showStatus("돔 이동 완료.", 2000);
                            }
                        }
                    }
                } else {
                    showStatus("돔 이동 완료.", 2000);
                }
                
                if (domeGroup && domeGroup.userData.anchor) { 
                    reticle.visible = false;
                } else if (!domeGroup) {
                    if (hitTestSource) reticle.visible = true;
                }
            }
        }
        
        function openSettingsModal() {
            document.getElementById('modalTargetSize').value = targetSize;
            document.getElementById('modalRadiusMultiplier').value = radiusMultiplier;
            document.getElementById('modalAzimuths').value = azimuths.join(',');
            document.getElementById('modalElevations').value = elevations.join(',');
            settingsModal.style.display = 'block';
        }

        function closeSettingsModal() {
            settingsModal.style.display = 'none';
        }

        function applySettingsFromModal() {
            targetSize = parseFloat(document.getElementById('modalTargetSize').value) || 100;
            radiusMultiplier = parseFloat(document.getElementById('modalRadiusMultiplier').value) || 3;
            azimuths = document.getElementById('modalAzimuths').value.split(',').map(Number).filter(n => !isNaN(n));
            elevations = document.getElementById('modalElevations').value.split(',').map(Number).filter(n => !isNaN(n));
            
            document.getElementById('targetSize').value = targetSize;
            document.getElementById('radiusMultiplier').value = radiusMultiplier;
            document.getElementById('azimuths').value = azimuths.join(',');
            document.getElementById('elevations').value = elevations.join(',');

            closeSettingsModal();
            showStatus("설정 적용됨. 돔이 배치되어 있다면 업데이트됩니다.", 2500);
            if (renderer.xr.isPresenting && domeGroup) {
                updateAndPlaceDome();
            }
        }

        async function controlTorch(enable) {
            if (!currentStream && enable) {
                 try {
                    console.log("Attempting to acquire camera stream for torch...");
                    currentStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } });
                    console.log("Camera stream for torch acquired.");
                 } catch(err) {
                    console.error("손전등 제어를 위한 카메라 스트림 확보 실패:", err);
                    showStatus("손전등 제어 불가: 카메라 접근 실패", 2500);
                    return false;
                 }
            } else if (!currentStream && !enable) {
                console.log("Torch control: No stream to turn off torch.");
                isTorchOn = false;
                torchButton.textContent = "손전등 켜기";
                return true; 
            }

            const videoTrack = currentStream ? currentStream.getVideoTracks()[0] : null;
            if (!videoTrack) {
                showStatus("손전등 제어 불가: 비디오 트랙 없음", 2500);
                console.warn("Torch control: No video track found in stream.");
                 if (!enable && currentStream) {
                    currentStream.getTracks().forEach(track => { if (track.readyState === 'live') track.stop(); });
                    currentStream = null;
                }
                return false;
            }

            const capabilities = videoTrack.getCapabilities ? videoTrack.getCapabilities() : {};
            if (!capabilities.torch) {
                showStatus("이 기기/브라우저에서는 손전등 기능을 지원하지 않습니다.", 3000);
                console.warn("Torch control: Torch capability not supported by video track.");
                if (!enable && currentStream) {
                    currentStream.getTracks().forEach(track => { if (track.readyState === 'live') track.stop(); });
                    currentStream = null;
                }
                return false;
            }

            try {
                await videoTrack.applyConstraints({
                    advanced: [{ torch: enable }]
                });
                isTorchOn = enable;
                torchButton.textContent = enable ? "손전등 끄기" : "손전등 켜기";
                showStatus(enable ? "손전등 켜짐" : "손전등 꺼짐", 1500);
                console.log(`Torch ${enable ? 'enabled' : 'disabled'}.`);

                if (!enable && currentStream) { 
                    console.log("Releasing camera stream after turning off torch.");
                    currentStream.getTracks().forEach(track => {
                        if (track.readyState === 'live') track.stop();
                    });
                    currentStream = null;
                }
                return true;
            } catch (err) {
                console.error("손전등 제어 실패:", err);
                showStatus("손전등 제어 중 오류 발생", 2500);
                if (!enable && currentStream) {
                    currentStream.getTracks().forEach(track => { if (track.readyState === 'live') track.stop(); });
                    currentStream = null;
                }
                return false;
            }
        }
        
        async function toggleTorch() {
            await controlTorch(!isTorchOn);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            renderer.setAnimationLoop(render);
        }

        function render(timestamp, frame) {
            const session = renderer.xr.getSession();
            if (!session) {
                renderer.render(scene, camera);
                return;
            }
            
            if (frame && hitTestSource) {
                const referenceSpace = renderer.xr.getReferenceSpace();
                if (!referenceSpace) return;

                const hitTestResults = frame.getHitTestResults(hitTestSource);
                if (hitTestResults.length > 0) {
                    const hit = hitTestResults[0];
                    const hitPose = hit.getPose(referenceSpace);
                    if (hitPose) {
                        // Reticle should be visible if no anchored dome, or if dragging an anchored dome to a new spot.
                        // Or if simply no dome exists yet.
                        if (!domeGroup || (domeGroup && !domeGroup.userData.anchor) || (domeGroup && domeGroup.userData.anchor && isDraggingDome)) {
                           reticle.visible = true;
                           reticle.matrix.fromArray(hitPose.transform.matrix);
                        } else { // Anchored dome exists and not dragging it
                           reticle.visible = false;
                        }
                        
                        if (isDraggingDome && domeGroup) {
                            domeGroup.position.copy(hitPose.transform.position);
                            // domeGroup.quaternion.copy(hitPose.transform.orientation); // Optional
                        }
                    }
                } else { // No hit test results this frame
                    // Keep reticle visible if it was supposed to be (e.g., no dome or dragging)
                    if (!domeGroup || (domeGroup && !domeGroup.userData.anchor) || (domeGroup && domeGroup.userData.anchor && isDraggingDome)) {
                        // Reticle might not have a valid position if no hits, but keep it 'logically' visible
                        // It might just not render if its matrix isn't updated to a valid pose.
                        // Or, explicitly hide if no surface is found for an extended period (more complex logic)
                    } else {
                        reticle.visible = false;
                    }
                }
            } else if (frame && !hitTestSource) { 
                 reticle.visible = false; // No hit-test source, definitely hide reticle
            }
            
            // Update anchored dome's position if it exists and not being actively dragged
            if (domeGroup && domeGroup.userData.anchor && !isDraggingDome) {
                const anchor = domeGroup.userData.anchor;
                if (frame && anchor.anchorSpace) { // XRAnchor has anchorSpace
                    const pose = frame.getPose(anchor.anchorSpace, renderer.xr.getReferenceSpace());
                    if (pose) {
                        domeGroup.position.copy(pose.transform.position);
                        domeGroup.quaternion.copy(pose.transform.orientation);
                    }
                }
            }
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>

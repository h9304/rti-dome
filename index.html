<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>RTI Lighting Dome</title>
    <script src="https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/webxr/ARButton.js"></script>
    <style>
      body { margin: 0; overflow: hidden; font-family: sans-serif; }
      #flashBtn { position: absolute; top: 10px; right: 10px; z-index: 1; }
      #inputPanel { position: absolute; top: 10px; left: 10px; background: rgba(255,255,255,0.8); padding: 10px; border-radius: 10px; z-index: 1; }
    </style>
  </head>
  <body>
    <div id="inputPanel">
      <label>Target size (mm): <input id="targetSize" type="number" value="100"></label><br>
      <label>Dome scale (2~4): <input id="domeScale" type="number" value="3" min="2" max="4"></label><br>
      <label>Azimuths (째, comma-separated): <input id="azimuths" type="text" value="0,45,90,135,180,225,270,315"></label><br>
      <label>Elevations (째, comma-separated): <input id="elevations" type="text" value="15,30,45,60"></label><br>
      <button onclick="generateDome()">Generate Dome</button>
    </div>
    <button id="flashBtn">Toggle Flash</button>
    <script>
      let scene, camera, renderer, controller, domeGroup;
      let flashOn = false;

      init();

      function init() {
        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;
        document.body.appendChild(renderer.domElement);

        document.body.appendChild(ARButton.createButton(renderer, { requiredFeatures: ['hit-test'] }));

        controller = renderer.xr.getController(0);
        scene.add(controller);

        domeGroup = new THREE.Group();
        scene.add(domeGroup);

        animate();
      }

      function generateDome() {
        domeGroup.clear();

        const size = parseFloat(document.getElementById('targetSize').value) / 1000; // mm to meters
        const scale = parseFloat(document.getElementById('domeScale').value);
        const azimuths = document.getElementById('azimuths').value.split(',').map(Number);
        const elevations = document.getElementById('elevations').value.split(',').map(Number);

        const domeRadius = size * scale / 2;

        const geometry = new THREE.SphereGeometry(domeRadius, 32, 32, 0, Math.PI * 2, 0, Math.PI / 2);
        const material = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.3, side: THREE.DoubleSide });
        const dome = new THREE.Mesh(geometry, material);
        domeGroup.add(dome);

        for (let el of elevations) {
          for (let az of azimuths) {
            const theta = THREE.MathUtils.degToRad(az);
            const phi = THREE.MathUtils.degToRad(el);

            const x = domeRadius * Math.sin(phi) * Math.cos(theta);
            const y = domeRadius * Math.cos(phi);
            const z = domeRadius * Math.sin(phi) * Math.sin(theta);

            const marker = new THREE.Mesh(
              new THREE.SphereGeometry(0.005),
              new THREE.MeshStandardMaterial({ color: 0xffff00 })
            );
            marker.position.set(x, y, z);

            const label = makeLabel(`${az}째,${el}째`);
            label.visible = false;
            marker.add(label);

            marker.userData.label = label;

            marker.callback = () => {
              label.visible = !label.visible;
            };

            domeGroup.add(marker);
          }
        }

        // allow drag (rudimentary)
        let dragging = false;
        let offset = new THREE.Vector3();

        controller.addEventListener('selectstart', () => { dragging = true; });
        controller.addEventListener('selectend', () => { dragging = false; });
        controller.addEventListener('select', () => {
          domeGroup.children.forEach(obj => {
            if (obj.callback) {
              const distance = obj.position.distanceTo(controller.position);
              if (distance < 0.03) obj.callback();
            }
          });
        });

        renderer.setAnimationLoop(() => {
          if (dragging) domeGroup.position.copy(controller.position);
          renderer.render(scene, camera);
        });
      }

      function makeLabel(text) {
        const canvas = document.createElement('canvas');
        const context = canvas.getContext('2d');
        canvas.width = 256;
        canvas.height = 64;
        context.fillStyle = 'white';
        context.fillRect(0, 0, canvas.width, canvas.height);
        context.fillStyle = 'black';
        context.font = '24px sans-serif';
        context.fillText(text, 10, 40);
        const texture = new THREE.CanvasTexture(canvas);
        const material = new THREE.SpriteMaterial({ map: texture });
        const sprite = new THREE.Sprite(material);
        sprite.scale.set(0.1, 0.025, 1);
        sprite.position.set(0, 0.02, 0);
        return sprite;
      }

      document.getElementById('flashBtn').addEventListener('click', () => {
        flashOn = !flashOn;
        alert('Flash ' + (flashOn ? 'ON' : 'OFF'));
        // Note: Direct control of device flashlight is not yet supported in WebXR
        // Would require native integration or browser support
      });

      function animate() {
        renderer.setAnimationLoop(() => {
          renderer.render(scene, camera);
        });
      }
    </script>
  </body>
</html>

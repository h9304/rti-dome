<!DOCTYPE html><html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>RTI 돔 위치 지정</title>
  <style>
    body { margin: 0; background: #000; color: #fff; font-family: sans-serif; }
    #video { position: fixed; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; z-index: 0; }
    #ui {
      position: absolute; top: 10px; left: 10px; z-index: 2;
      background: rgba(0,0,0,0.7); padding: 12px; border-radius: 8px; max-width: 300px;
    }
    label { display: block; font-size: 13px; margin-top: 8px; }
    input, select { width: 100%; padding: 4px; margin-top: 4px; border-radius: 4px; border: none; }
    button { margin-top: 10px; width: 100%; padding: 8px; border: none; border-radius: 4px; background: #28a745; color: #fff; font-weight: bold; cursor: pointer; }
    canvas { position: fixed; top: 0; left: 0; z-index: 1; }
    #crosshair {
      position: absolute; top: 50%; left: 50%; width: 30px; height: 30px;
      margin: -15px 0 0 -15px; border: 2px solid white; border-radius: 50%; pointer-events: none; z-index: 3;
    }
  </style>
</head>
<body>
  <video id="video" autoplay playsinline muted></video>
  <canvas id="canvas"></canvas>
  <div id="crosshair"></div>  <div id="ui">
    <label>대상 크기 (mm):<br><input type="number" id="targetSize" value="100"></label>
    <label>돔 배율:<br><select id="sizeMultiplier"><option value="2">2×</option><option value="3" selected>3×</option><option value="4">4×</option></select></label>
    <label>방위각 (°, 콤마):<br><input type="text" id="azimuths" value="0,90,180,270"></label>
    <label>고도각 (°, 콤마):<br><input type="text" id="elevations" value="30,45,60"></label>
    <button id="generate">돔 생성</button>
  </div>  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';
    import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js';

    let scene, camera, renderer, domeGroup;
    let controls;

    const canvas = document.getElementById('canvas');
    renderer = new THREE.WebGLRenderer({ canvas, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);

    scene = new THREE.Scene();
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 1.5, 2);

    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.target.set(0, 0, 0);

    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(5, 5, 5);
    scene.add(light);

    document.getElementById('generate').onclick = () => {
      const radius = getRadius();
      const azs = getArray('azimuths');
      const els = getArray('elevations');
      generateDome(radius, azs, els);
    };

    function getRadius() {
      const size = parseFloat(document.getElementById('targetSize').value);
      const multiplier = parseFloat(document.getElementById('sizeMultiplier').value);
      return (size * multiplier) / 1000;
    }

    function getArray(id) {
      return document.getElementById(id).value.split(',').map(v => parseFloat(v.trim())).filter(v => !isNaN(v));
    }

    function generateDome(radius, azimuths, elevations) {
      if (domeGroup) scene.remove(domeGroup);
      domeGroup = new THREE.Group();

      const dome = new THREE.Mesh(
        new THREE.SphereGeometry(radius, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2),
        new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.3, side: THREE.DoubleSide })
      );
      domeGroup.add(dome);

      const markerGeo = new THREE.SphereGeometry(0.01, 8, 8);
      const markerMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });

      azimuths.forEach(az => {
        elevations.forEach(el => {
          const t = THREE.MathUtils.degToRad(az);
          const p = THREE.MathUtils.degToRad(el);
          const x = radius * Math.cos(p) * Math.sin(t);
          const y = radius * Math.sin(p);
          const z = radius * Math.cos(p) * Math.cos(t);
          const marker = new THREE.Mesh(markerGeo, markerMat);
          marker.position.set(x, y, z);
          domeGroup.add(marker);
        });
      });

      const center = getReticleWorldPosition();
      domeGroup.position.copy(center);
      scene.add(domeGroup);
    }

    function getReticleWorldPosition() {
      const x = 0;
      const y = 0;
      const vector = new THREE.Vector3(x, y, 0.5);
      vector.unproject(camera);

      const dir = vector.sub(camera.position).normalize();
      const distance = (camera.position.y - 0) / dir.y; // assuming y=0 is the floor
      return camera.position.clone().sub(dir.multiplyScalar(distance));
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }

    animate();

    async function startCamera() {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } });
        document.getElementById('video').srcObject = stream;
      } catch (e) {
        alert('카메라를 사용할 수 없습니다: ' + e.message);
      }
    }

    startCamera();
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script></body>
</html>

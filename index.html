<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RTI AR 돔 가이드</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            color: #fff;
            font-family: Arial, sans-serif;
            overflow: hidden;
            position: relative;
        }
        
        #videoContainer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }
        
        #video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: auto;
        }
        
        #controls {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border-radius: 10px;
            max-width: 320px;
            backdrop-filter: blur(10px);
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
            color: #ccc;
        }
        
        .control-group input, .control-group select, .control-group textarea {
            width: 100%;
            padding: 5px;
            border: 1px solid #555;
            background: #333;
            color: #fff;
            border-radius: 3px;
            box-sizing: border-box;
        }
        
        .control-group textarea {
            resize: vertical;
            height: 60px;
            font-family: monospace;
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        button {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 5px;
            background: #007bff;
            color: white;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
        }
        
        button:hover {
            background: #0056b3;
        }
        
        button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        
        #flash-btn {
            background: #ffc107;
            color: #000;
        }
        
        #flash-btn:hover {
            background: #e0a800;
        }
        
        #flash-btn.active {
            background: #dc3545;
            color: #fff;
        }
        
        #start-camera-btn {
            background: #28a745;
        }
        
        #start-camera-btn:hover {
            background: #1e7e34;
        }
        
        #info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.9);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 100;
            backdrop-filter: blur(10px);
        }
        
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 30px;
            height: 30px;
            border: 2px solid #fff;
            border-radius: 50%;
            pointer-events: none;
            z-index: 50;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }
        
        #crosshair::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 4px;
            height: 4px;
            background: #fff;
            border-radius: 50%;
        }
        
        .geodesic-info {
            font-size: 10px;
            color: #aaa;
            margin-top: 5px;
        }
        
        .status {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 5px;
            font-size: 12px;
            z-index: 100;
        }
        
        .status.error {
            background: rgba(220, 53, 69, 0.9);
        }
        
        .status.success {
            background: rgba(40, 167, 69, 0.9);
        }
        
        .hidden {
            display: none;
        }
        
        #elevation-help {
            font-size: 10px;
            color: #aaa;
            margin-top: 2px;
        }
    </style>
</head>
<body>
    <div id="videoContainer">
        <video id="video" autoplay playsinline muted></video>
    </div>
    
    <canvas id="canvas"></canvas>
    <div id="crosshair"></div>
    
    <div id="status" class="status hidden"></div>
    
    <div id="controls">
        <div class="control-group">
            <label>대상 크기 (cm)</label>
            <input type="number" id="targetSize" value="10" min="1" max="100">
        </div>
        
        <div class="control-group">
            <label>돔 배율</label>
            <select id="domeMultiplier">
                <option value="2">2배</option>
                <option value="3" selected>3배</option>
                <option value="4">4배</option>
            </select>
            <div id="dome-size-display" class="geodesic-info">돔 크기: 30cm</div>
        </div>
        
        <div class="control-group">
            <label>방위각 분할</label>
            <select id="azimuthDivision">
                <option value="8">8방향</option>
                <option value="10" selected>10방향</option>
                <option value="12">12방향</option>
            </select>
        </div>
        
        <div class="control-group">
            <label>고도각 (도, 콤마로 구분)</label>
            <textarea id="elevationAngles" placeholder="예: 15, 30, 45, 60">30, 45, 60</textarea>
            <div id="elevation-help">각도를 콤마로 구분하여 입력 (0-85도)</div>
        </div>
        
        <div class="control-group">
            <label>
                <input type="checkbox" id="geodesicMode"> Geodesic 패턴 사용
            </label>
            <div class="geodesic-info">
                더 균등한 조명 분포를 위한 정이십면체 기반 패턴
            </div>
        </div>
        
        <div class="button-group">
            <button id="start-camera-btn" onclick="startCamera()">카메라 시작</button>
            <button onclick="generateDome()">돔 생성</button>
        </div>
        
        <div class="button-group">
            <button id="flash-btn" onclick="toggleFlash()" disabled>플래시 OFF</button>
            <button onclick="clearDome()">초기화</button>
        </div>
        
        <div class="button-group">
            <button onclick="toggleControls()">컨트롤 숨기기</button>
        </div>
    </div>
    
    <div id="info">
        카메라: <span id="cameraStatus">대기중</span><br>
        플래시: <span id="flashStatus">OFF</span><br>
        클릭: 조명 마커 생성/제거<br>
        마커 개수: <span id="markerCount">0</span>
    </div>

    <script>
        let scene, camera, renderer, dome, markers = [];
        let video, canvas, ctx;
        let cameraStream = null, flashTrack = null;
        let isDragging = false, previousMousePosition = { x: 0, y: 0 };
        let targetSize = 10, domeRadius = 0.15; // 미터 단위
        let flashOn = false;
        let controlsVisible = true;
        let deviceOrientation = { alpha: 0, beta: 0, gamma: 0 };
        
        function init() {
            // 비디오 요소
            video = document.getElementById('video');
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');
            
            // 캔버스 크기 설정
            resizeCanvas();
            
            // Three.js 설정
            scene = new THREE.Scene();
            
            // 카메라 설정 (AR용)
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.01, 1000);
            camera.position.set(0, 0, 0);
            
            // 렌더러 설정
            renderer = new THREE.WebGLRenderer({ 
                canvas: canvas,
                alpha: true,
                antialias: true 
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000, 0); // 투명 배경
            
            // 이벤트 리스너
            canvas.addEventListener('click', onCanvasClick);
            canvas.addEventListener('touchstart', onTouchStart, { passive: false });
            canvas.addEventListener('touchend', onTouchEnd, { passive: false });
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('deviceorientation', onDeviceOrientation);
            
            // 컨트롤 업데이트
            document.getElementById('targetSize').addEventListener('input', updateDomeSize);
            document.getElementById('domeMultiplier').addEventListener('change', updateDomeSize);
            
            updateDomeSize();
            animate();
        }
        
        async function startCamera() {
            try {
                showStatus('카메라 권한을 요청하고 있습니다...', 'info');
                
                // 카메라 권한 요청
                const constraints = {
                    video: {
                        facingMode: 'environment', // 후면 카메라
                        width: { ideal: 1920 },
                        height: { ideal: 1080 }
                    }
                };
                
                cameraStream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = cameraStream;
                
                // 플래시 트랙 찾기
                const videoTracks = cameraStream.getVideoTracks();
                if (videoTracks.length > 0) {
                    flashTrack = videoTracks[0];
                    
                    // 플래시 기능 확인
                    const capabilities = flashTrack.getCapabilities();
                    if (capabilities.torch) {
                        document.getElementById('flash-btn').disabled = false;
                        showStatus('카메라가 시작되었습니다. 플래시 사용 가능!', 'success');
                    } else {
                        showStatus('카메라가 시작되었습니다. (플래시 지원 안됨)', 'info');
                    }
                } else {
                    showStatus('카메라가 시작되었습니다.', 'success');
                }
                
                document.getElementById('cameraStatus').textContent = '활성';
                document.getElementById('start-camera-btn').textContent = '카메라 재시작';
                
                // 비디오가 로드되면 캔버스 크기 조정
                video.addEventListener('loadedmetadata', resizeCanvas);
                
            } catch (error) {
                console.error('카메라 접근 오류:', error);
                showStatus('카메라 접근 실패: ' + error.message, 'error');
                document.getElementById('cameraStatus').textContent = '오류';
            }
        }
        
        async function toggleFlash() {
            if (!flashTrack) {
                showStatus('카메라가 시작되지 않았습니다.', 'error');
                return;
            }
            
            try {
                flashOn = !flashOn;
                
                // 플래시 제어
                await flashTrack.applyConstraints({
                    advanced: [{ torch: flashOn }]
                });
                
                const flashBtn = document.getElementById('flash-btn');
                const flashStatus = document.getElementById('flashStatus');
                
                if (flashOn) {
                    flashBtn.textContent = '플래시 ON';
                    flashBtn.classList.add('active');
                    flashStatus.textContent = 'ON';
                    showStatus('플래시가 켜졌습니다.', 'success');
                } else {
                    flashBtn.textContent = '플래시 OFF';
                    flashBtn.classList.remove('active');
                    flashStatus.textContent = 'OFF';
                    showStatus('플래시가 꺼졌습니다.', 'info');
                }
                
            } catch (error) {
                console.error('플래시 제어 오류:', error);
                showStatus('플래시 제어 실패: ' + error.message, 'error');
            }
        }
        
        function generateDome() {
            clearDome();
            
            targetSize = parseFloat(document.getElementById('targetSize').value);
            const multiplier = parseFloat(document.getElementById('domeMultiplier').value);
            const azimuthCount = parseInt(document.getElementById('azimuthDivision').value);
            const elevationText = document.getElementById('elevationAngles').value;
            const useGeodesic = document.getElementById('geodesicMode').checked;
            
            // 고도각 파싱
            const elevationAngles = elevationText
                .split(',')
                .map(angle => parseFloat(angle.trim()))
                .filter(angle => !isNaN(angle) && angle >= 0 && angle <= 85);
            
            if (elevationAngles.length === 0) {
                showStatus('유효한 고도각을 입력해주세요 (0-85도)', 'error');
                return;
            }
            
            domeRadius = (targetSize * multiplier) / 200; // 미터 단위로 변환 (반지름)
            
            // 돔 구조 생성 (반투명 검은색 반구)
            const domeGeometry = new THREE.SphereGeometry(domeRadius, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2);
            const domeMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x000000,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide
            });
            
            dome = new THREE.Mesh(domeGeometry, domeMaterial);
            dome.position.set(0, 0, -domeRadius); // 카메라 앞에 위치
            scene.add(dome);
            
            // 와이어프레임 추가 (가이드용)
            const wireframeGeometry = domeGeometry.clone();
            const wireframeMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x555555,
                wireframe: true,
                transparent: true,
                opacity: 0.5
            });
            const wireframe = new THREE.Mesh(wireframeGeometry, wireframeMaterial);
            wireframe.position.copy(dome.position);
            scene.add(wireframe);
            
            // 중심 마커
            const centerGeometry = new THREE.SphereGeometry(0.005, 8, 8);
            const centerMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
            const centerMarker = new THREE.Mesh(centerGeometry, centerMaterial);
            centerMarker.position.set(0, 0, -domeRadius);
            scene.add(centerMarker);
            
            generateLightPositions(azimuthCount, elevationAngles, useGeodesic);
            showStatus(`돔이 생성되었습니다. (${elevationAngles.length}개 고도각)`, 'success');
        }
        
        function generateLightPositions(azimuthCount, elevationAngles, useGeodesic) {
            const positions = [];
            
            if (useGeodesic) {
                positions.push(...generateGeodesicPositions());
            } else {
                elevationAngles.forEach(elevationDeg => {
                    const elevation = elevationDeg * Math.PI / 180;
                    const ringRadius = domeRadius * Math.cos(elevation);
                    const height = domeRadius * Math.sin(elevation);
                    
                    for (let a = 0; a < azimuthCount; a++) {
                        const azimuth = (a * 2 * Math.PI) / azimuthCount;
                        const x = ringRadius * Math.cos(azimuth);
                        const z = ringRadius * Math.sin(azimuth) - domeRadius;
                        
                        positions.push({
                            x: x,
                            y: height,
                            z: z,
                            azimuth: azimuth * 180 / Math.PI,
                            elevation: elevationDeg
                        });
                    }
                });
            }
            
            // 위치 표시 점들 생성
            positions.forEach(pos => {
                const pointGeometry = new THREE.SphereGeometry(0.003, 8, 8);
                const pointMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0x00ff00,
                    transparent: true,
                    opacity: 0.8
                });
                const point = new THREE.Mesh(pointGeometry, pointMaterial);
                point.position.set(pos.x, pos.y, pos.z);
                point.userData = {
                    azimuth: pos.azimuth,
                    elevation: pos.elevation,
                    isLightPosition: true
                };
                scene.add(point);
            });
        }
        
        function generateGeodesicPositions() {
            const phi = (1 + Math.sqrt(5)) / 2;
            const positions = [];
            
            const vertices = [
                [-1, phi, 0], [1, phi, 0], [-1, -phi, 0], [1, -phi, 0],
                [0, -1, phi], [0, 1, phi], [0, -1, -phi], [0, 1, -phi],
                [phi, 0, -1], [phi, 0, 1], [-phi, 0, -1], [-phi, 0, 1]
            ];
            
            vertices.forEach(vertex => {
                const [x, y, z] = vertex;
                const length = Math.sqrt(x*x + y*y + z*z);
                const normalizedX = (x / length) * domeRadius;
                const normalizedY = Math.abs(y / length) * domeRadius;
                const normalizedZ = (z / length) * domeRadius - domeRadius;
                
                if (normalizedY > 0.01) {
                    const azimuth = Math.atan2(normalizedZ + domeRadius, normalizedX) * 180 / Math.PI;
                    const elevation = Math.asin(normalizedY / domeRadius) * 180 / Math.PI;
                    
                    positions.push({
                        x: normalizedX,
                        y: normalizedY,
                        z: normalizedZ,
                        azimuth: azimuth < 0 ? azimuth + 360 : azimuth,
                        elevation: elevation
                    });
                }
            });
            
            return positions;
        }
        
        function onCanvasClick(event) {
            if (isDragging) return;
            
            const rect = canvas.getBoundingClientRect();
            const mouse = new THREE.Vector2();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);
            
            // 기존 마커 클릭 확인
            const markerIntersects = raycaster.intersectObjects(markers);
            if (markerIntersects.length > 0) {
                const marker = markerIntersects[0].object;
                toggleMarkerInfo(marker);
                return;
            }
            
            // 돔 표면에 새 마커 생성
            if (dome) {
                const domeIntersects = raycaster.intersectObject(dome);
                if (domeIntersects.length > 0) {
                    const intersectionPoint = domeIntersects[0].point;
                    createMarker(intersectionPoint);
                }
            }
        }
        
        function onTouchStart(event) {
            event.preventDefault();
            if (event.touches.length === 1) {
                const touch = event.touches[0];
                onCanvasClick(touch);
            }
        }
        
        function onTouchEnd(event) {
            event.preventDefault();
        }
        
        function createMarker(position) {
            const markerGeometry = new THREE.SphereGeometry(0.008, 8, 8);
            const markerMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
            const marker = new THREE.Mesh(markerGeometry, markerMaterial);
            
            marker.position.copy(position);
            
            // 각도 계산 (돔 중심 기준)
            const relativePosX = position.x;
            const relativePosY = position.y;
            const relativePosZ = position.z + domeRadius;
            
            const azimuth = Math.atan2(relativePosZ, relativePosX) * 180 / Math.PI;
            const elevation = Math.asin(relativePosY / domeRadius) * 180 / Math.PI;
            
            marker.userData = {
                azimuth: azimuth < 0 ? azimuth + 360 : azimuth,
                elevation: Math.max(0, elevation),
                showInfo: false
            };
            
            markers.push(marker);
            scene.add(marker);
            updateMarkerCount();
        }
        
        function toggleMarkerInfo(marker) {
            if (marker.userData.showInfo) {
                // 정보 숨기기
                if (marker.userData.infoSprite) {
                    scene.remove(marker.userData.infoSprite);
                    marker.userData.infoSprite = null;
                }
                marker.userData.showInfo = false;
            } else {
                // 정보 표시
                showMarkerInfo(marker);
            }
        }
        
        function showMarkerInfo(marker) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 200;
            canvas.height = 60;
            
            context.fillStyle = 'rgba(0, 0, 0, 0.9)';
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            context.fillStyle = 'white';
            context.font = '14px Arial';
            context.fillText(`방위각: ${marker.userData.azimuth.toFixed(1)}°`, 10, 20);
            context.fillText(`고도: ${marker.userData.elevation.toFixed(1)}°`, 10, 40);
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMaterial);
            
            sprite.position.copy(marker.position);
            sprite.position.y += 0.02;
            sprite.scale.set(0.05, 0.03, 1);
            
            scene.add(sprite);
            marker.userData.infoSprite = sprite;
            marker.userData.showInfo = true;
        }
        
        function clearDome() {
            if (dome) {
                scene.remove(dome);
                dome = null;
            }
            
            markers.forEach(marker => {
                scene.remove(marker);
                if (marker.userData.infoSprite) {
                    scene.remove(marker.userData.infoSprite);
                }
            });
            markers = [];
            
            // 모든 관련 객체 제거
            const objectsToRemove = [];
            scene.traverse(child => {
                if (child.userData && (child.userData.isLightPosition || child.material?.wireframe)) {
                    objectsToRemove.push(child);
                }
            });
            objectsToRemove.forEach(obj => scene.remove(obj));
            
            updateMarkerCount();
            showStatus('돔이 초기화되었습니다.', 'info');
        }
        
        function updateDomeSize() {
            const targetSize = parseFloat(document.getElementById('targetSize').value);
            const multiplier = parseFloat(document.getElementById('domeMultiplier').value);
            const domeSize = targetSize * multiplier;
            document.getElementById('dome-size-display').textContent = `돔 크기: ${domeSize}cm`;
        }
        
        function toggleControls() {
            const controls = document.getElementById('controls');
            controlsVisible = !controlsVisible;
            controls.style.display = controlsVisible ? 'block' : 'none';
            
            const btn = event.target;
            btn.textContent = controlsVisible ? '컨트롤 숨기기' : '컨트롤 보이기';
        }
        
        function updateMarkerCount() {
            document.getElementById('markerCount').textContent = markers.length;
        }
        
        function showStatus(message, type = 'info') {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = `status ${type}`;
            status.classList.remove('hidden');
            
            setTimeout(() => {
                status.classList.add('hidden');
            }, 3000);
        }
        
        function onDeviceOrientation(event) {
            deviceOrientation.alpha = event.alpha || 0;
            deviceOrientation.beta = event.beta || 0;
            deviceOrientation.gamma = event.gamma || 0;
            
            // 디바이스 회전에 따른 카메라 회전 (선택적)
            if (camera) {
                camera.rotation.z = deviceOrientation.gamma * Math.PI / 180;
            }
        }
        
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            if (renderer) {
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
            if (camera) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
            }
        }
        
        function onWindowResize() {
            resizeCanvas();
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            // AR 렌더링: 비디오 위에 3D 오버레이
            if (video.readyState === video.HAVE_ENOUGH_DATA) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }
            
            renderer.render(scene, camera);
        }
        
        // 초기화
        document.addEventListener('DOMContentLoaded', function() {
            init();
            
            // 권한 요청 안내
            showStatus('카메라 시작 버튼을 눌러 AR 모드를 활성화하세요.', 'info');
        });
        
        // 페이지 종료 시 카메라 스트림 정리
        window.addEventListener('beforeunload', function() {
            if (cameraStream) {
                cameraStream.getTracks().forEach(track => track.stop());
            }
        });
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>WebXR RTI Dome (v19 Custom Marker 10cm)</title>
    <style>
        body { 
            margin: 0; 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; 
            overflow: hidden; 
            background-color: #000; 
            color: #fff; 
            overscroll-behavior: none;
        }
        #mainContainer {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(20,20,20,0.85);
            padding: 15px;
            border-radius: 12px;
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 12px;
            max-width: calc(100% - 40px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.1);
        }
        #settingsModal {
            display: none; 
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            background: rgba(30,30,30,0.97);
            padding: 25px;
            border-radius: 15px;
            z-index: 101; 
            width: 90%;
            max-width: 380px;
            box-shadow: 0 8px 30px rgba(0,0,0,0.6);
            border: 1px solid rgba(255,255,255,0.15);
            flex-direction: column;
            gap: 12px;
        }
        .input-group label {
            font-size: 0.9em;
            color: #ccc;
            margin-bottom: 3px;
            display: block;
        }
        .input-group input, .input-group select {
            width: calc(100% - 18px); 
            padding: 10px; 
            border-radius: 6px; 
            border: 1px solid #444; 
            background: #2a2a2a;
            color: #fff;
            font-size: 0.95em;
            box-sizing: border-box;
        }
        .input-group input:focus, .input-group select:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 2px rgba(0,123,255,0.25);
        }
        .input-group.disabled {
            opacity: 0.5;
            pointer-events: none;
        }
        #mainContainer button, #arModeControls button, #settingsModal button {
            padding: 12px 15px; 
            background-color: #007bff; 
            color: white;
            border: none; 
            border-radius: 6px; 
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.2s ease;
        }
        #mainContainer button:hover, #arModeControls button:hover, #settingsModal button:hover {
            background-color: #0056b3;
        }
        #arButton {
            position: absolute !important; 
            bottom: 20px !important;
            left: 50% !important;
            transform: translateX(-50%) !important;
            padding: 12px 20px !important;
            background-color: #28a745 !important;
            color: white !important;
            border: none !important;
            border-radius: 8px !important;
            font-size: 1.1em !important;
            z-index: 100 !important;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3) !important;
        }
        #statusMessage {
            position: absolute;
            bottom: 80px; 
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.75);
            padding: 10px 15px;
            border-radius: 8px;
            color: white;
            z-index: 10;
            text-align: center;
            font-size: 0.9em;
            display: none; 
            max-width: 80%;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        #arModeControls {
            display: none; /* Initially hidden */
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 20;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        #arModeControls button {
            background-color: #17a2b8; 
            font-size: 0.9em;
        }
        #arModeControls button:hover {
            background-color: #117a8b;
        }
        #settingsModal h3 {
            margin-top: 0;
            margin-bottom: 20px;
            color: #00aeff;
            text-align: center;
            font-size: 1.3em;
        }
        #settingsModal .modal-actions {
            display: flex;
            justify-content: space-around;
            margin-top: 25px;
        }
         #settingsModal .modal-actions button {
            width: 45%;
         }
         #settingsModal #applyModalSettingsButton {
            background-color: #28a745; 
         }
         #settingsModal #applyModalSettingsButton:hover {
            background-color: #1e7e34; 
         }
         #settingsModal #closeModalButton {
            background-color: #dc3545; 
         }
         #settingsModal #closeModalButton:hover {
            background-color: #b02a37;
         }
         #crosshair {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            width: 30px;
            height: 30px;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 32px;
            line-height: 30px;
            text-align: center;
            font-weight: normal;
            z-index: 5;
            pointer-events: none;
            text-shadow: 0 0 5px rgba(0,0,0,0.8);
            transition: color 0.2s, transform 0.2s;
        }
        #crosshair.aligned {
            color: #4CAF50; /* Green */
            transform: translate(-50%, -50%) scale(1.3);
        }
        #marker-info {
            background: #333;
            padding: 10px;
            border-radius: 8px;
            margin-top: 10px;
        }
        #marker-info p { margin: 5px 0; font-size: 0.8em; }
        #marker-info img { max-width: 80px; border-radius: 4px; }
        #marker-info a { color: #87ceeb; }
    </style>
</head>
<body>
    <div id="mainContainer">
        <div id="marker-info">
             <p><b>필수: AR 마커 준비</b></p>
             <img id="markerImage" src="./images/markerimg-02-01.jpg" alt="AR Marker">
             <p>1. 위 이미지를 다운로드 받으세요.</p>
             <p>2. 가로 <b>10cm</b> 크기로 인쇄하세요.</p>
             <a id="downloadMarkerLink" href="./images/markerimg-02-01.jpg" download="rti_marker.jpg">마커 이미지 다운로드</a>
        </div>
        <div class="input-group">
            <label for="domeType">돔 타입:</label>
            <select id="domeType">
                <option value="free">자유 배치</option>
                <option value="geodesic">3v 지오데식 (상/하단 제외)</option>
            </select>
        </div>
        <div class="input-group">
            <label for="domeRadius">돔 반지름 (cm):</label>
            <input type="number" id="domeRadius" value="30">
        </div>
        <div class="input-group" id="azimuths-group">
            <label for="azimuths">방위각 리스트 (°): (예: 0,45,90)</label>
            <input type="text" id="azimuths" value="0,45,90,135,180,225,270,315">
        </div>
        <div class="input-group" id="elevations-group">
            <label for="elevations">고도각 리스트 (°): (예: 15,30,45)</label>
            <input type="text" id="elevations" value="15,30,45,60,75">
        </div>
    </div>

    <div id="arModeControls">
        <button id="arSettingsButton">입력값</button>
    </div>

    <div id="settingsModal" style="display: none;">
        <h3>AR 설정</h3>
        <div class="input-group">
            <label for="modalDomeType">돔 타입:</label>
            <select id="modalDomeType">
                <option value="free">자유 배치</option>
                <option value="geodesic">3v 지오데식 (상/하단 제외)</option>
            </select>
        </div>
        <div class="input-group">
            <label for="modalDomeRadius">돔 반지름 (cm):</label>
            <input type="number" id="modalDomeRadius">
        </div>
        <div class="input-group" id="modal-azimuths-group">
            <label for="modalAzimuths">방위각 리스트 (°):</label>
            <input type="text" id="modalAzimuths">
        </div>
        <div class="input-group" id="modal-elevations-group">
            <label for="modalElevations">고도각 리스트 (°):</label>
            <input type="text" id="modalElevations">
        </div>
        <div class="modal-actions">
            <button id="applyModalSettingsButton">적용</button>
            <button id="closeModalButton">닫기</button>
        </div>
    </div>
    
    <div id="crosshair">+</div>
    <div id="statusMessage"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { ARButton } from 'three/addons/webxr/ARButton.js';
        import { ConvexGeometry } from 'three/addons/geometries/ConvexGeometry.js';

        let camera, scene, renderer;
        let controller;
        let domeGroup = null; 
        let domeCenterTarget = null;
        
        let domeType = 'free';
        let domeRadiusCm = 30; 
        let azimuths = [];
        let elevations = [];

        const raycaster = new THREE.Raycaster();
        const statusMessageEl = document.getElementById('statusMessage'); 
        const mainContainer = document.getElementById('mainContainer');
        const arModeControls = document.getElementById('arModeControls');
        const settingsModal = document.getElementById('settingsModal');
        const crosshairEl = document.getElementById('crosshair');

        let markerImageBitmap = null;
        let isDomePlacedByMarker = false;

        function showStatus(message, duration = 3000) {
            if (statusMessageEl) { 
                statusMessageEl.textContent = message;
                statusMessageEl.style.display = 'block';
                if (statusMessageEl.timeoutId) clearTimeout(statusMessageEl.timeoutId);
                if (duration > 0) {
                    statusMessageEl.timeoutId = setTimeout(() => {
                        statusMessageEl.style.display = 'none';
                    }, duration);
                }
            }
        }
        
        function updateDomeTypeUI(type, prefix = '') {
            const azGroup = document.getElementById(`${prefix}azimuths-group`);
            const elGroup = document.getElementById(`${prefix}elevations-group`);
            if (type === 'geodesic') {
                azGroup.classList.add('disabled');
                elGroup.classList.add('disabled');
            } else {
                azGroup.classList.remove('disabled');
                elGroup.classList.remove('disabled');
            }
        }

        function syncAndReadInputs() {
            domeType = document.getElementById('domeType').value;
            domeRadiusCm = parseFloat(document.getElementById('domeRadius').value) || 30;
            azimuths = document.getElementById('azimuths').value.split(',').map(Number).filter(n => !isNaN(n));
            elevations = document.getElementById('elevations').value.split(',').map(Number).filter(n => !isNaN(n));
        }

        async function init() {
            scene = new THREE.Scene();
            scene.add(new THREE.AmbientLight(0x888888,1.2));
            const directionalLight = new THREE.DirectionalLight(0xffffff, 2.8);
            directionalLight.position.set(0.5, 1, 0.75).normalize();
            scene.add(directionalLight);

            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 40);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);
            
            // Marker image must be loaded before AR Button is created
            const markerImgEl = document.getElementById('markerImage');
            try {
                showStatus("마커 이미지 로딩 중...", 0);
                const response = await fetch(markerImgEl.src);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const blob = await response.blob();
                markerImageBitmap = await createImageBitmap(blob);
                
                const arButtonElement = ARButton.createButton(renderer, {
                    requiredFeatures: ['image-tracking', 'dom-overlay', 'anchors'], 
                    trackedImages: [
                        {
                            image: markerImageBitmap,
                            widthInMeters: 0.1 // The physical width of the printed marker (10cm)
                        }
                    ],
                    domOverlay: { root: document.body } 
                });
                arButtonElement.id = 'arButton';
                document.body.appendChild(arButtonElement);
                showStatus("마커 이미지 준비 완료. AR을 시작하세요.", 5000);

            } catch (error) {
                console.error("Failed to load marker image:", error);
                showStatus("오류: 마커 이미지를 로드할 수 없습니다. 경로를 확인하세요.", 0);
            }

            controller = renderer.xr.getController(0);
            controller.addEventListener('selectstart', onSelectStart);
            scene.add(controller);

            document.getElementById('domeType').addEventListener('change', (e) => updateDomeTypeUI(e.target.value));
            document.getElementById('modalDomeType').addEventListener('change', (e) => updateDomeTypeUI(e.target.value, 'modal-'));
            
            document.getElementById('arSettingsButton').addEventListener('click', openSettingsModal);
            document.getElementById('applyModalSettingsButton').addEventListener('click', applySettingsFromModal);
            document.getElementById('closeModalButton').addEventListener('click', closeSettingsModal);
            
            syncAndReadInputs();
            updateDomeTypeUI(domeType);
            
            window.addEventListener('resize', onWindowResize);

            renderer.xr.addEventListener('sessionstart', () => {
                showStatus("카메라를 움직여 마커를 찾아주세요.", 0); 
                mainContainer.style.display = 'none';
                arModeControls.style.display = 'flex';
                crosshairEl.style.display = 'block';
            });

            renderer.xr.addEventListener('sessionend', () => {
                clearDomeAndChildren();
                showStatus("AR 세션 종료됨.", 3000);
                mainContainer.style.display = 'flex';
                arModeControls.style.display = 'none';
                crosshairEl.style.display = 'none';
                crosshairEl.classList.remove('aligned');
                closeSettingsModal();
                isDomePlacedByMarker = false;
            });
        }
        
        function placeOrUpdateDome(matrix) {
            if (!domeGroup) { 
                domeGroup = createDome();
                scene.add(domeGroup);
                showStatus("마커 인식! 돔이 배치되었습니다.", 3000);
            }
            domeGroup.position.setFromMatrixPosition(matrix);
            domeGroup.quaternion.setFromRotationMatrix(matrix);
        }
        
        function clearDomeAndChildren() {
            if (!domeGroup) return;
            domeGroup.traverse(child => {
                if (child.isMesh) {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(m => { if (m.map) m.map.dispose(); m.dispose(); });
                        } else {
                            if (child.material.map) child.material.map.dispose(); child.material.dispose();
                        }
                    }
                }
                if (child.isSprite && child.material) {
                     if (child.material.map) child.material.map.dispose(); child.material.dispose();
                }
            });
            scene.remove(domeGroup);
            domeGroup = null;
            domeCenterTarget = null;
        }

        function createDome() {
            const newDomeGroup = new THREE.Group();
            const innerGroup = new THREE.Group();
            newDomeGroup.add(innerGroup);

            const actualRadius = Math.max(0.01, domeRadiusCm / 100);

            const markerRadius = Math.max(0.003, actualRadius * 0.025); 
            const markerGeometry = new THREE.SphereGeometry(markerRadius, 12, 6);
            const markerMaterial = new THREE.MeshStandardMaterial({ color: 0xFFD700, metalness: 0.3, roughness: 0.4 });
            let markerCount = 0;
            
            const domeVisualMaterial = new THREE.MeshStandardMaterial({
                color: 0x101010, transparent: true, opacity: 0.65, side: THREE.DoubleSide,
                metalness: 0.1, roughness: 0.9,
            });

            if (domeType === 'geodesic') {
                const geoGeom = new THREE.IcosahedronGeometry(actualRadius, 3);

                const t = (1 + Math.sqrt(5)) / 2;
                const sourceVertex = new THREE.Vector3(0, 1, t).normalize(); 
                const targetVertex = new THREE.Vector3(0, 1, 0);
                const quaternion = new THREE.Quaternion().setFromUnitVectors(sourceVertex, targetVertex);
                geoGeom.applyQuaternion(quaternion);
                
                const vertices = geoGeom.attributes.position;
                const uniqueVertices = new Map();
                for (let i = 0; i < vertices.count; i++) {
                    const x = vertices.getX(i);
                    const y = vertices.getY(i);
                    const z = vertices.getZ(i);
                    const key = `${x.toFixed(4)},${y.toFixed(4)},${z.toFixed(4)}`;
                    if (!uniqueVertices.has(key)) {
                        uniqueVertices.set(key, new THREE.Vector3(x, y, z));
                    }
                }

                const allDomeVertices = Array.from(uniqueVertices.values())
                    .filter(v => v.y >= -actualRadius * 0.38);
                
                if (allDomeVertices.length > 0) {
                    const guideGeom = new ConvexGeometry(allDomeVertices);
                    const guideMesh = new THREE.Mesh(guideGeom, domeVisualMaterial);
                    guideMesh.userData.isDomePart = true;
                    innerGroup.add(guideMesh);

                    let minY = Infinity;
                    allDomeVertices.forEach(v => {
                        if (v.y < minY) minY = v.y;
                    });
                    innerGroup.position.y = -minY;

                    let maxY = -Infinity;
                    allDomeVertices.forEach(v => {
                        if (v.y > maxY) maxY = v.y;
                    });

                    const tolerance = 0.001;
                    const markerVertices = allDomeVertices.filter(v => {
                        return Math.abs(v.y - maxY) > tolerance && Math.abs(v.y - minY) > tolerance;
                    });

                    const sortedMarkerVertices = markerVertices.sort((a, b) => {
                        if (Math.abs(a.y - b.y) > tolerance) {
                            return b.y - a.y;
                        }
                        return Math.atan2(a.z, a.x) - Math.atan2(b.z, b.x);
                    });

                    sortedMarkerVertices.forEach(pos => {
                        markerCount++;
                        const marker = new THREE.Mesh(markerGeometry, markerMaterial.clone());
                        marker.position.copy(pos);
                        marker.userData = { 
                            isLightMarker: true, isGeodesic: true,
                            coordinates: {x: pos.x, y: pos.y, z: pos.z},
                            number: markerCount, azElLabelMesh: null, isAzElLabelVisible: false,
                        };
                        addNumberLabelToMarker(marker, innerGroup, actualRadius);
                        innerGroup.add(marker);
                    });
                }

            } else { // 'free' type
                const domeVisualGeometry = new THREE.SphereGeometry(actualRadius, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2);
                const hemisphere = new THREE.Mesh(domeVisualGeometry, domeVisualMaterial);
                hemisphere.userData.isDomePart = true;
                innerGroup.add(hemisphere);

                (elevations || []).forEach(el => {
                    (azimuths || []).forEach(az => {
                        if (isNaN(el) || isNaN(az)) return;
                        markerCount++;
                        const elRad = THREE.MathUtils.degToRad(el);
                        const azRad = THREE.MathUtils.degToRad(az);
                        const x = actualRadius * Math.cos(elRad) * Math.cos(azRad);
                        const y = actualRadius * Math.sin(elRad); 
                        const z = actualRadius * Math.cos(elRad) * Math.sin(azRad);

                        const marker = new THREE.Mesh(markerGeometry, markerMaterial.clone());
                        marker.position.set(x, y, z);
                        marker.userData = { 
                            isLightMarker: true, isGeodesic: false,
                            azimuth: az, elevation: el, number: markerCount,
                            azElLabelMesh: null, isAzElLabelVisible: false,
                        };
                        addNumberLabelToMarker(marker, innerGroup, actualRadius);
                        innerGroup.add(marker);
                    });
                });
            }
            
            const targetMarkerRadius = actualRadius * 0.05;
            const targetMarkerGeometry = new THREE.CircleGeometry(targetMarkerRadius, 32);
            const targetMarkerMaterial = new THREE.MeshBasicMaterial({ color: 0x888888, side: THREE.DoubleSide, transparent: true, opacity: 0.7 });
            domeCenterTarget = new THREE.Mesh(targetMarkerGeometry, targetMarkerMaterial);
            domeCenterTarget.rotation.x = -Math.PI / 2; 
            domeCenterTarget.renderOrder = 1;
            innerGroup.add(domeCenterTarget);

            newDomeGroup.userData.isDomeRoot = true;
            newDomeGroup.userData.anchor = null; 
            return newDomeGroup;
        }

        function addNumberLabelToMarker(marker, group, radius) {
            const markerRadius = marker.geometry.parameters.radius;
            const numberLabelText = `${marker.userData.number}`;
            const numberLabelMesh = createTextSprite(numberLabelText, {
                fontsize: 28, fontface: "Arial",
                textColor: { r: 255, g: 230, b: 100, a: 1.0 }, 
                backgroundColor: { r: 0, g: 0, b: 0, a: 0.0 } 
            });
            const numberLabelScaleFactor = radius * 0.03;
            numberLabelMesh.scale.set(numberLabelScaleFactor, numberLabelScaleFactor * 0.7, numberLabelScaleFactor);
            const offsetDirection = marker.position.clone().normalize();
            const numberLabelOffset = markerRadius * 2.2; 
            numberLabelMesh.position.copy(marker.position).add(offsetDirection.multiplyScalar(numberLabelOffset));
            group.add(numberLabelMesh);
            marker.userData.numberLabelMesh = numberLabelMesh;
        }

        function onSelectStart(event) {
            if (domeGroup) {
                const controller = event.target; 
                const tempMatrix = new THREE.Matrix4();
                tempMatrix.identity().extractRotation(controller.matrixWorld); 
                raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld); 
                raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix); 

                const intersects = raycaster.intersectObject(domeGroup, true);
                if (intersects.length > 0) {
                    const firstIntersected = intersects[0].object;
                    if (firstIntersected.userData.isLightMarker) {
                        toggleMarkerAzElLabel(firstIntersected);
                        return; 
                    }
                }
            }
        }
        
        function toggleMarkerAzElLabel(marker) {
            marker.userData.isAzElLabelVisible = !marker.userData.isAzElLabelVisible;
            if (marker.userData.isAzElLabelVisible) {
                if (!marker.userData.azElLabelMesh) {
                    let labelText;
                    if (marker.userData.isGeodesic) {
                        const coords = marker.userData.coordinates;
                        labelText = `X:${coords.x.toFixed(2)} Y:${coords.y.toFixed(2)} Z:${coords.z.toFixed(2)}`;
                    } else {
                        labelText = `${marker.userData.azimuth}°, ${marker.userData.elevation}°`;
                    }
                    marker.userData.azElLabelMesh = createTextSprite(labelText, { 
                        fontsize: 20, fontface: "Arial", 
                        textColor: { r:200, g:255, b:200, a:1.0 }, 
                        backgroundColor: { r:50, g:50, b:50, a:0.7 }
                    });
                    const domeRadius = (domeGroup.children[0]?.children.find(c => c.userData.isDomePart)?.geometry.parameters.radius) || 1;
                    const labelScaleFactor = domeRadius * 0.05; 
                    marker.userData.azElLabelMesh.scale.set(labelScaleFactor * (marker.userData.isGeodesic ? 5 : 3), labelScaleFactor * 0.8, labelScaleFactor); 

                    if (marker.userData.numberLabelMesh) {
                        marker.userData.azElLabelMesh.position.copy(marker.userData.numberLabelMesh.position).add(new THREE.Vector3(0, -labelScaleFactor * 0.9, 0.001)); 
                    } else { 
                        const offsetDirection = marker.position.clone().normalize();
                        marker.userData.azElLabelMesh.position.copy(marker.position.clone().add(offsetDirection.multiplyScalar(0.03)));
                    }
                    domeGroup.children[0].add(marker.userData.azElLabelMesh); 
                }
                marker.userData.azElLabelMesh.visible = true;
            } else {
                if (marker.userData.azElLabelMesh) marker.userData.azElLabelMesh.visible = false;
            }
        }

        function createTextSprite(message, parameters = {}) {
            const fontface = parameters.fontface || 'Arial';
            const fontsize = parameters.fontsize || 20;
            const backgroundColor = parameters.backgroundColor || { r:0, g:0, b:0, a:0.5 };
            const textColor = parameters.textColor || { r:255, g:255, b:255, a:1.0 };
            const padding = parameters.padding || 8; 
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            context.font = `Bold ${fontsize}px ${fontface}`;
            const metrics = context.measureText(message);
            const textWidth = metrics.width;
            canvas.width = textWidth + padding * 2;
            canvas.height = fontsize * 1.4 + padding * 2; 
            context.font = `Bold ${fontsize}px ${fontface}`; 
            context.fillStyle = `rgba(${backgroundColor.r},${backgroundColor.g},${backgroundColor.b},${backgroundColor.a})`;
            const radius = 6; 
            context.beginPath();
            context.moveTo(radius, 0);
            context.lineTo(canvas.width - radius, 0);
            context.quadraticCurveTo(canvas.width, 0, canvas.width, radius);
            context.lineTo(canvas.width, canvas.height - radius);
            context.quadraticCurveTo(canvas.width, canvas.height, canvas.width - radius, canvas.height);
            context.lineTo(radius, canvas.height);
            context.quadraticCurveTo(0, canvas.height, 0, canvas.height - radius);
            context.lineTo(0, radius);
            context.quadraticCurveTo(0, 0, radius, 0);
            context.closePath();
            context.fill();
            context.fillStyle = `rgba(${textColor.r},${textColor.g},${textColor.b},${textColor.a})`;
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(message, canvas.width / 2, canvas.height / 2);
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture, depthTest: false, transparent: true });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(canvas.width / (fontsize * 5) , canvas.height / (fontsize * 5), 1.0); 
            return sprite;
        }
        
        function openSettingsModal() {
            document.getElementById('modalDomeType').value = domeType;
            document.getElementById('modalDomeRadius').value = domeRadiusCm;
            document.getElementById('modalAzimuths').value = azimuths.join(',');
            document.getElementById('modalElevations').value = elevations.join(',');
            updateDomeTypeUI(domeType, 'modal-');
            settingsModal.style.display = 'flex';
        }
        function closeSettingsModal() { settingsModal.style.display = 'none'; }
        function applySettingsFromModal() {
            domeType = document.getElementById('modalDomeType').value;
            domeRadiusCm = parseFloat(document.getElementById('modalDomeRadius').value) || 30;
            azimuths = document.getElementById('modalAzimuths').value.split(',').map(Number).filter(n => !isNaN(n));
            elevations = document.getElementById('modalElevations').value.split(',').map(Number).filter(n => !isNaN(n));
            
            document.getElementById('domeType').value = domeType;
            document.getElementById('domeRadius').value = domeRadiusCm;
            document.getElementById('azimuths').value = azimuths.join(',');
            document.getElementById('elevations').value = elevations.join(',');
            updateDomeTypeUI(domeType);
            closeSettingsModal();
            if(renderer.xr.isPresenting && domeGroup){
                 isDomePlacedByMarker = false;
                 clearDomeAndChildren();
                 showStatus("마커를 다시 찾아 돔을 업데이트하세요.", 3000);
            } else {
                showStatus("설정 적용됨.", 2500);
            }
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            renderer.setAnimationLoop(render);
        }

        const screenCenter = new THREE.Vector2(0, 0);
        const targetScreenPos = new THREE.Vector2();

        function render(timestamp, frame) {
            if (!frame) {
                renderer.render(scene, camera);
                return;
            }
            
            const referenceSpace = renderer.xr.getReferenceSpace();
            if (!referenceSpace) return;
            
            // Marker tracking logic
            const trackedImages = frame.getImageTrackingResults();
            let markerFound = false;
            for (const image of trackedImages) {
                if (image.trackingState == 'tracked') {
                    markerFound = true;
                    const pose = frame.getPose(image.imageSpace, referenceSpace);
                    if (!isDomePlacedByMarker) {
                         syncAndReadInputs();
                    }
                    placeOrUpdateDome(new THREE.Matrix4().fromArray(pose.transform.matrix));
                    isDomePlacedByMarker = true;
                    if(domeGroup && !domeGroup.visible) domeGroup.visible = true;
                    break; 
                }
            }
            
            if (domeCenterTarget) {
                const targetWorldPos = new THREE.Vector3();
                domeCenterTarget.getWorldPosition(targetWorldPos);
                const projectedPos = targetWorldPos.clone().project(camera);
                targetScreenPos.set(projectedPos.x, projectedPos.y);

                if (projectedPos.z < 1) {
                     const distance = screenCenter.distanceTo(targetScreenPos);
                     const alignmentThreshold = 0.05; 
                     if (distance < alignmentThreshold) {
                        crosshairEl.classList.add('aligned');
                     } else {
                        crosshairEl.classList.remove('aligned');
                     }
                } else {
                    crosshairEl.classList.remove('aligned');
                }
            } else {
                 crosshairEl.classList.remove('aligned');
            }
            
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>


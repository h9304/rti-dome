<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>WebXR RTI Dome (v10 Geodesic Option)</title>
    <style>
        body { 
            margin: 0; 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; 
            overflow: hidden; 
            background-color: #000; 
            color: #fff; 
            overscroll-behavior: none;
        }
        #inputContainer, #settingsModal {
            position: absolute;
            top: 10px;
            background: rgba(20,20,20,0.85);
            padding: 15px;
            border-radius: 12px;
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 12px;
            max-width: calc(100% - 40px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.1);
        }
        #inputContainer { left: 10px; }
        #settingsModal {
            display: none; 
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            z-index: 101; 
            width: 90%;
            max-width: 380px;
        }
        .input-group label {
            font-size: 0.9em;
            color: #ccc;
            margin-bottom: 3px;
            display: block;
        }
        .input-group input, .input-group select {
            width: calc(100% - 18px); 
            padding: 10px; 
            border-radius: 6px; 
            border: 1px solid #444; 
            background: #2a2a2a;
            color: #fff;
            font-size: 0.95em;
            box-sizing: border-box;
        }
        .input-group input:focus, .input-group select:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 2px rgba(0,123,255,0.25);
        }
        .input-group.disabled {
            opacity: 0.5;
            pointer-events: none;
        }
        #inputContainer button, #arModeControls button, #settingsModal button {
            padding: 12px 15px; 
            background-color: #007bff; 
            color: white;
            border: none; 
            border-radius: 6px; 
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.2s ease;
        }
        #inputContainer button:hover, #arModeControls button:hover, #settingsModal button:hover {
            background-color: #0056b3;
        }
        #arButton {
            position: absolute !important; 
            bottom: 20px !important;
            left: 50% !important;
            transform: translateX(-50%) !important;
            padding: 12px 20px !important;
            background-color: #28a745 !important;
            color: white !important;
            border: none !important;
            border-radius: 8px !important;
            font-size: 1.1em !important;
            z-index: 100 !important;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3) !important;
        }
        #statusMessage {
            position: absolute;
            bottom: 80px; 
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.75);
            padding: 10px 15px;
            border-radius: 8px;
            color: white;
            z-index: 10;
            text-align: center;
            font-size: 0.9em;
            display: none; 
            max-width: 80%;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        #arModeControls {
            display: none; /* Initially hidden */
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 20;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        #arModeControls button {
            background-color: #17a2b8; 
            font-size: 0.9em;
        }
        #arModeControls button#resetDomePositionButton { 
            background-color: #ffc107; 
            color: #212529;
        }
        #arModeControls button#resetDomePositionButton:hover {
             background-color: #e0a800;
        }
        #arModeControls button:hover {
            background-color: #117a8b;
        }
        #settingsModal h3 {
            margin-top: 0;
            margin-bottom: 20px;
            color: #00aeff;
            text-align: center;
            font-size: 1.3em;
        }
        #settingsModal .modal-actions {
            display: flex;
            justify-content: space-around;
            margin-top: 25px;
        }
         #settingsModal .modal-actions button {
            width: 45%;
         }
         #settingsModal #applyModalSettingsButton {
            background-color: #28a745; 
         }
         #settingsModal #applyModalSettingsButton:hover {
            background-color: #1e7e34; 
         }
         #settingsModal #closeModalButton {
            background-color: #dc3545; 
         }
         #settingsModal #closeModalButton:hover {
            background-color: #b02a37;
         }
         #crosshair {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            width: 30px;
            height: 30px;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 32px;
            line-height: 30px;
            text-align: center;
            font-weight: normal;
            z-index: 5;
            pointer-events: none; /* Make it non-interactive */
            text-shadow: 0 0 5px rgba(0,0,0,0.8);
            transition: color 0.2s, transform 0.2s;
        }
        #crosshair.aligned {
            color: #4CAF50; /* Green */
            transform: translate(-50%, -50%) scale(1.3);
        }
    </style>
</head>
<body>
    <div id="inputContainer">
        <div class="input-group">
            <label for="domeType">돔 타입:</label>
            <select id="domeType">
                <option value="free">자유 배치</option>
                <option value="geodesic">5/8 지오데식 (3v)</option>
            </select>
        </div>
        <div class="input-group">
            <label for="targetSize">대상 실제 크기 (mm):</label>
            <input type="number" id="targetSize" value="100">
        </div>
        <div class="input-group">
            <label for="radiusMultiplier">돔 반지름 배율 (대상 크기의 N배, 2-4):</label>
            <input type="number" id="radiusMultiplier" value="3" min="2" max="4" step="0.1">
        </div>
        <div class="input-group" id="azimuths-group">
            <label for="azimuths">방위각 리스트 (°): (예: 0,45,90)</label>
            <input type="text" id="azimuths" value="0,45,90,135,180,225,270,315">
        </div>
        <div class="input-group" id="elevations-group">
            <label for="elevations">고도각 리스트 (°): (예: 15,30,45)</label>
            <input type="text" id="elevations" value="15,30,45,60,75">
        </div>
        <button id="generateDomeButton">돔 생성/업데이트 (AR 시작 후)</button>
    </div>

    <div id="arModeControls">
        <button id="arSettingsButton">입력값</button>
        <button id="resetDomePositionButton">돔 위치 재설정</button>
    </div>

    <div id="settingsModal">
        <h3>AR 설정</h3>
        <div class="input-group">
            <label for="modalDomeType">돔 타입:</label>
            <select id="modalDomeType">
                <option value="free">자유 배치</option>
                <option value="geodesic">5/8 지오데식 (3v)</option>
            </select>
        </div>
        <div class="input-group">
            <label for="modalTargetSize">대상 실제 크기 (mm):</label>
            <input type="number" id="modalTargetSize">
        </div>
        <div class="input-group">
            <label for="modalRadiusMultiplier">돔 반지름 배율 (2-4):</label>
            <input type="number" id="modalRadiusMultiplier" min="2" max="4" step="0.1">
        </div>
        <div class="input-group" id="modal-azimuths-group">
            <label for="modalAzimuths">방위각 리스트 (°):</label>
            <input type="text" id="modalAzimuths">
        </div>
        <div class="input-group" id="modal-elevations-group">
            <label for="modalElevations">고도각 리스트 (°):</label>
            <input type="text" id="modalElevations">
        </div>
        <div class="modal-actions">
            <button id="applyModalSettingsButton">적용</button>
            <button id="closeModalButton">닫기</button>
        </div>
    </div>
    
    <div id="crosshair">+</div>
    <div id="statusMessage"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { ARButton } from 'three/addons/webxr/ARButton.js';

        let camera, scene, renderer;
        let controller;
        let reticle; 
        let domeGroup = null; 
        let hitTestSource = null;
        let domeCenterTarget = null;
        
        let domeType = 'free';
        let targetSize = 100; 
        let radiusMultiplier = 3;
        let azimuths = [];
        let elevations = [];

        const raycaster = new THREE.Raycaster();
        const statusMessageEl = document.getElementById('statusMessage'); 
        const inputContainer = document.getElementById('inputContainer');
        const arModeControls = document.getElementById('arModeControls');
        const settingsModal = document.getElementById('settingsModal');
        const resetDomePositionButton = document.getElementById('resetDomePositionButton');
        const crosshairEl = document.getElementById('crosshair');

        let placementRequested = false;
        let allowReticleUpdate = true; 

        let isDraggingDome = false;
        let activePointerId = null; 

        function showStatus(message, duration = 3000) {
            if (statusMessageEl) { 
                statusMessageEl.textContent = message;
                statusMessageEl.style.display = 'block';
                if (statusMessageEl.timeoutId) clearTimeout(statusMessageEl.timeoutId);
                if (duration > 0) {
                    statusMessageEl.timeoutId = setTimeout(() => {
                        statusMessageEl.style.display = 'none';
                    }, duration);
                }
            }
        }
        
        function updateDomeTypeUI(type, prefix = '') {
            const azGroup = document.getElementById(`${prefix}azimuths-group`);
            const elGroup = document.getElementById(`${prefix}elevations-group`);
            if (type === 'geodesic') {
                azGroup.classList.add('disabled');
                elGroup.classList.add('disabled');
            } else {
                azGroup.classList.remove('disabled');
                elGroup.classList.remove('disabled');
            }
        }

        function syncAndReadInputs() {
            domeType = document.getElementById('domeType').value;
            targetSize = parseFloat(document.getElementById('targetSize').value) || 100;
            radiusMultiplier = parseFloat(document.getElementById('radiusMultiplier').value) || 3;
            azimuths = document.getElementById('azimuths').value.split(',').map(Number).filter(n => !isNaN(n));
            elevations = document.getElementById('elevations').value.split(',').map(Number).filter(n => !isNaN(n));
        }

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.add(new THREE.AmbientLight(0x888888,1.2));
            const directionalLight = new THREE.DirectionalLight(0xffffff, 2.8);
            directionalLight.position.set(0.5, 1, 0.75).normalize();
            scene.add(directionalLight);

            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 40);

            reticle = new THREE.Mesh(
                new THREE.RingGeometry(0.03, 0.04, 32), 
                new THREE.MeshBasicMaterial({ color: 0xffffff, opacity: 0.9, transparent: true, depthTest: false, side: THREE.DoubleSide })
            );
            reticle.matrixAutoUpdate = false;
            reticle.visible = false;
            scene.add(reticle);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);

            const arButtonElement = ARButton.createButton(renderer, {
                requiredFeatures: ['hit-test', 'dom-overlay'], 
                optionalFeatures: ['anchors', 'plane-detection'], 
                domOverlay: { root: document.body } 
            });
            document.body.appendChild(arButtonElement);
            arButtonElement.id = 'arButton';

            controller = renderer.xr.getController(0);
            controller.addEventListener('selectstart', onSelectStart);
            scene.add(controller);

            document.getElementById('domeType').addEventListener('change', (e) => updateDomeTypeUI(e.target.value));
            document.getElementById('modalDomeType').addEventListener('change', (e) => updateDomeTypeUI(e.target.value, 'modal-'));
            
            document.getElementById('generateDomeButton').addEventListener('click', () => {
                syncAndReadInputs();
                if (!renderer.xr.isPresenting) {
                    showStatus("AR 세션을 먼저 시작해주세요.", 3000);
                    return;
                }
                if (domeGroup) { 
                    updateAndPlaceDome();
                } else { 
                    allowReticleUpdate = true;
                    showStatus("돔을 배치할 위치를 탭하세요.", 3000);
                }
            });
            
            resetDomePositionButton.addEventListener('click', () => {
                if (renderer.xr.isPresenting) {
                    allowReticleUpdate = true; 
                    reticle.visible = true; 
                    placementRequested = false; 
                    showStatus("돔을 새로 배치할 위치를 탭하세요.", 3000);
                }
            });

            document.getElementById('arSettingsButton').addEventListener('click', openSettingsModal);
            document.getElementById('applyModalSettingsButton').addEventListener('click', applySettingsFromModal);
            document.getElementById('closeModalButton').addEventListener('click', closeSettingsModal);
            
            syncAndReadInputs();
            updateDomeTypeUI(domeType);

            renderer.domElement.addEventListener('pointerdown', onPointerDown, false);
            renderer.domElement.addEventListener('pointermove', onPointerMove, false);
            renderer.domElement.addEventListener('pointerup', onPointerUp, false);
            renderer.domElement.addEventListener('pointercancel', onPointerUp, false);
            
            window.addEventListener('resize', onWindowResize);

            renderer.xr.addEventListener('sessionstart', async () => {
                showStatus("AR 세션 시작됨. 표면을 찾아 레티클을 조준하고 탭하여 돔 배치.", 0); 
                inputContainer.style.display = 'none';
                arModeControls.style.display = 'flex';
                crosshairEl.style.display = 'block';
                allowReticleUpdate = true; 
                const session = renderer.xr.getSession();

                try {
                    const viewerReferenceSpace = await session.requestReferenceSpace('viewer');
                    hitTestSource = await session.requestHitTestSource({ 
                        space: viewerReferenceSpace,
                        entityTypes: ['plane'] 
                    });
                    if (!hitTestSource) {
                        showStatus("표면 감지(plane) 실패, 일반 모드로 시도.", 2000);
                        hitTestSource = await session.requestHitTestSource({ space: viewerReferenceSpace }); 
                         if (!hitTestSource) showStatus("표면 감지 기능을 시작할 수 없습니다.", 4000);
                    }
                } catch (error) {
                    console.error("Hit-test source 요청 실패:", error);
                     try { 
                        const viewerReferenceSpace = await session.requestReferenceSpace('viewer');
                        hitTestSource = await session.requestHitTestSource({ space: viewerReferenceSpace });
                        if (!hitTestSource) {
                             showStatus("표면 감지 기능(Hit-test)을 시작할 수 없습니다. (fallback)", 4000);
                        } else {
                            showStatus("표면 감지: 일반 모드로 전환됨.", 2000);
                        }
                    } catch (fallbackError) {
                        console.error("Fallback Hit-test source 요청 실패:", fallbackError);
                        showStatus("Hit-test를 시작할 수 없습니다. AR 기능이 제한될 수 있습니다.", 4000);
                    }
                }
            });

            renderer.xr.addEventListener('sessionend', () => {
                hitTestSource = null;
                reticle.visible = false;
                allowReticleUpdate = true; 
                clearDomeAndChildren();
                showStatus("AR 세션 종료됨.", 3000);
                inputContainer.style.display = 'block';
                arModeControls.style.display = 'none';
                crosshairEl.style.display = 'none';
                crosshairEl.classList.remove('aligned');
                closeSettingsModal();
            });
            showStatus("AR 세션을 시작하고, 바닥이나 벽을 탭하여 돔을 배치하세요.", 5000); 
        }
        
        function updateAndPlaceDome(hitMatrix = null, frameForAnchor = null) {
            if (domeGroup && !hitMatrix) { 
                const oldAnchor = domeGroup.userData.anchor;
                const oldPosition = domeGroup.position.clone();
                const oldQuaternion = domeGroup.quaternion.clone();
                clearDomeAndChildren();
                domeGroup = createDome();
                if (oldAnchor) {
                    domeGroup.userData.anchor = oldAnchor; 
                } else {
                    domeGroup.position.copy(oldPosition);
                    domeGroup.quaternion.copy(oldQuaternion);
                }
                scene.add(domeGroup);
                showStatus("돔 설정 업데이트 완료.", 2000);
                allowReticleUpdate = false; 
                reticle.visible = false;
            } else if (hitMatrix) { 
                clearDomeAndChildren();
                domeGroup = createDome();
                
                const referenceSpace = renderer.xr.getReferenceSpace();
                if (frameForAnchor && referenceSpace && hitMatrix.userData?.hitTestResult) {
                    const hit = hitMatrix.userData.hitTestResult;
                    hit.createAnchor().then(anchor => {
                        domeGroup.userData.anchor = anchor;
                        scene.add(domeGroup);
                        showStatus("돔 배치 완료 (앵커 사용).", 3000);
                    }).catch(err => {
                        console.warn("앵커 생성 실패:", err);
                        domeGroup.position.setFromMatrixPosition(hitMatrix);
                        domeGroup.quaternion.setFromRotationMatrix(hitMatrix);
                        scene.add(domeGroup);
                        showStatus("돔 배치 완료 (앵커 실패, 직접 배치).", 3000);
                    });
                } else { 
                    domeGroup.position.setFromMatrixPosition(hitMatrix);
                    domeGroup.quaternion.setFromRotationMatrix(hitMatrix);
                    scene.add(domeGroup);
                    showStatus("돔 배치 완료 (앵커 정보 없음).", 3000);
                }
                allowReticleUpdate = false; 
                reticle.visible = false;
            } else if (!domeGroup) { 
                showStatus("돔을 배치할 위치를 탭하세요.", 3000);
                allowReticleUpdate = true; 
            }
        }
        
        function clearDomeAndChildren() {
            if (!domeGroup) return;
            domeGroup.traverse(child => {
                if (child.isMesh) {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(m => { if (m.map) m.map.dispose(); m.dispose(); });
                        } else {
                            if (child.material.map) child.material.map.dispose(); child.material.dispose();
                        }
                    }
                }
                if (child.isSprite && child.material) {
                     if (child.material.map) child.material.map.dispose(); child.material.dispose();
                }
            });
            scene.remove(domeGroup);
            domeGroup = null;
            domeCenterTarget = null;
        }

        function createDome() {
            const newDomeGroup = new THREE.Group();
            const actualRadius = Math.max(0.01, (targetSize * radiusMultiplier) / 1000); 

            const domeVisualGeometry = new THREE.SphereGeometry(actualRadius, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2);
            const domeVisualMaterial = new THREE.MeshStandardMaterial({
                color: 0x101010, transparent: true, opacity: 0.65, side: THREE.DoubleSide,
                metalness: 0.1, roughness: 0.9,
            });
            const hemisphere = new THREE.Mesh(domeVisualGeometry, domeVisualMaterial);
            hemisphere.userData.isDomePart = true; 
            newDomeGroup.add(hemisphere);

            const targetMarkerRadius = actualRadius * 0.05;
            const targetMarkerGeometry = new THREE.CircleGeometry(targetMarkerRadius, 32);
            const targetMarkerMaterial = new THREE.MeshBasicMaterial({ color: 0x888888, side: THREE.DoubleSide, transparent: true, opacity: 0.7 });
            domeCenterTarget = new THREE.Mesh(targetMarkerGeometry, targetMarkerMaterial);
            domeCenterTarget.rotation.x = -Math.PI / 2; 
            domeCenterTarget.position.y = 0.001; 
            domeCenterTarget.userData.isCenterTarget = true;
            newDomeGroup.add(domeCenterTarget);

            const markerRadius = Math.max(0.003, actualRadius * 0.025); 
            const markerGeometry = new THREE.SphereGeometry(markerRadius, 12, 6);
            const markerMaterial = new THREE.MeshStandardMaterial({ color: 0xFFD700, metalness: 0.3, roughness: 0.4 });
            let markerCount = 0;

            if (domeType === 'geodesic') {
                const geoGeom = new THREE.IcosahedronGeometry(actualRadius, 3); // 3v

                // Reorient the geometry to have a vertex on top (Y-axis)
                const t = (1 + Math.sqrt(5)) / 2;
                const sourceVertex = new THREE.Vector3(0, 1, t).normalize(); 
                const targetVertex = new THREE.Vector3(0, 1, 0);
                const quaternion = new THREE.Quaternion().setFromUnitVectors(sourceVertex, targetVertex);
                geoGeom.applyQuaternion(quaternion);
                
                const vertices = geoGeom.attributes.position;
                const uniqueVertices = new Map();

                for (let i = 0; i < vertices.count; i++) {
                    const x = vertices.getX(i);
                    const y = vertices.getY(i);
                    const z = vertices.getZ(i);
                    
                    if (y > -actualRadius * 0.38) { // 5/8 sphere filter
                        const key = `${x.toFixed(4)},${y.toFixed(4)},${z.toFixed(4)}`;
                        if (!uniqueVertices.has(key)) {
                            uniqueVertices.set(key, new THREE.Vector3(x, y, z));
                        }
                    }
                }

                const sortedVertices = Array.from(uniqueVertices.values()).sort((a, b) => {
                    if (Math.abs(a.y - b.y) > 0.001) {
                        return b.y - a.y; // Sort from top to bottom
                    }
                    return Math.atan2(a.z, a.x) - Math.atan2(b.z, b.x); // Then by angle
                });

                sortedVertices.forEach(pos => {
                    markerCount++;
                    const marker = new THREE.Mesh(markerGeometry, markerMaterial.clone());
                    marker.position.copy(pos);
                    
                    marker.userData = { 
                        isLightMarker: true, 
                        isGeodesic: true,
                        coordinates: {x: pos.x, y: pos.y, z: pos.z},
                        number: markerCount,
                        azElLabelMesh: null, 
                        isAzElLabelVisible: false,
                    };
                    addNumberLabelToMarker(marker, newDomeGroup, actualRadius);
                    newDomeGroup.add(marker);
                });

            } else { // 'free' type
                (elevations || []).forEach(el => {
                    (azimuths || []).forEach(az => {
                        if (isNaN(el) || isNaN(az)) return;
                        markerCount++;
                        const elRad = THREE.MathUtils.degToRad(el);
                        const azRad = THREE.MathUtils.degToRad(az);
                        const x = actualRadius * Math.cos(elRad) * Math.cos(azRad);
                        const y = actualRadius * Math.sin(elRad); 
                        const z = actualRadius * Math.cos(elRad) * Math.sin(azRad);

                        const marker = new THREE.Mesh(markerGeometry, markerMaterial.clone());
                        marker.position.set(x, y, z);
                        
                        marker.userData = { 
                            isLightMarker: true, 
                            isGeodesic: false,
                            azimuth: az, 
                            elevation: el, 
                            number: markerCount,
                            azElLabelMesh: null, 
                            isAzElLabelVisible: false,
                        };
                        addNumberLabelToMarker(marker, newDomeGroup, actualRadius);
                        newDomeGroup.add(marker);
                    });
                });
            }
            
            newDomeGroup.userData.isDomeRoot = true;
            newDomeGroup.userData.anchor = null; 
            return newDomeGroup;
        }

        function addNumberLabelToMarker(marker, group, radius) {
            const markerRadius = marker.geometry.parameters.radius;
            const numberLabelText = `${marker.userData.number}`;
            const numberLabelMesh = createTextSprite(numberLabelText, {
                fontsize: 28, fontface: "Arial",
                textColor: { r: 255, g: 230, b: 100, a: 1.0 }, 
                backgroundColor: { r: 0, g: 0, b: 0, a: 0.0 } 
            });
            const numberLabelScaleFactor = radius * 0.03;
            numberLabelMesh.scale.set(numberLabelScaleFactor, numberLabelScaleFactor * 0.7, numberLabelScaleFactor);
            const offsetDirection = marker.position.clone().normalize();
            const numberLabelOffset = markerRadius * 2.2; 
            numberLabelMesh.position.copy(marker.position).add(offsetDirection.multiplyScalar(numberLabelOffset));
            group.add(numberLabelMesh);
            marker.userData.numberLabelMesh = numberLabelMesh;
        }

        function onSelectStart(event) {
            if (domeGroup) {
                const controller = event.target; 
                const tempMatrix = new THREE.Matrix4();
                tempMatrix.identity().extractRotation(controller.matrixWorld); 
                raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld); 
                raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix); 

                const intersects = raycaster.intersectObject(domeGroup, true);
                if (intersects.length > 0) {
                    const firstIntersected = intersects[0].object;
                    if (firstIntersected.userData.isLightMarker) {
                        toggleMarkerAzElLabel(firstIntersected);
                        return; 
                    }
                }
            }

            if (reticle.visible && allowReticleUpdate) { 
                placementRequested = true;
            } else if (!allowReticleUpdate && domeGroup) {
                showStatus("돔 위치를 변경하려면 '돔 위치 재설정' 버튼을 누르세요.", 2500);
            } else {
                 showStatus("레티클이 표면을 찾지 못했습니다. 다른 곳을 조준하세요.", 2500);
            }
        }
        
        function toggleMarkerAzElLabel(marker) {
            marker.userData.isAzElLabelVisible = !marker.userData.isAzElLabelVisible;

            if (marker.userData.isAzElLabelVisible) {
                if (!marker.userData.azElLabelMesh) {
                    let labelText;
                    if (marker.userData.isGeodesic) {
                        const coords = marker.userData.coordinates;
                        labelText = `X:${coords.x.toFixed(2)} Y:${coords.y.toFixed(2)} Z:${coords.z.toFixed(2)}`;
                    } else {
                        labelText = `${marker.userData.azimuth}°, ${marker.userData.elevation}°`;
                    }
                     
                    marker.userData.azElLabelMesh = createTextSprite(labelText, { 
                        fontsize: 20, fontface: "Arial", 
                        textColor: { r:200, g:255, b:200, a:1.0 }, 
                        backgroundColor: { r:50, g:50, b:50, a:0.7 }
                    });
                    
                    const domeRadius = domeGroup.children.find(c => c.userData.isDomePart)?.geometry.parameters.radius || 1;
                    const labelScaleFactor = domeRadius * 0.05; 
                    marker.userData.azElLabelMesh.scale.set(labelScaleFactor * (marker.userData.isGeodesic ? 5 : 3), labelScaleFactor * 0.8, labelScaleFactor); 

                    if (marker.userData.numberLabelMesh) {
                        const numberLabelPos = marker.userData.numberLabelMesh.position;
                        marker.userData.azElLabelMesh.position.copy(numberLabelPos).add(new THREE.Vector3(0, -labelScaleFactor * 0.9, 0.001)); 
                    } else { 
                        const offsetDirection = marker.position.clone().normalize();
                        const azElLabelPosition = marker.position.clone().add(offsetDirection.multiplyScalar(0.03));
                        marker.userData.azElLabelMesh.position.copy(azElLabelPosition);
                    }
                    domeGroup.add(marker.userData.azElLabelMesh); 
                }
                marker.userData.azElLabelMesh.visible = true;
            } else {
                if (marker.userData.azElLabelMesh) {
                    marker.userData.azElLabelMesh.visible = false;
                }
            }
        }

        function createTextSprite(message, parameters = {}) {
            const fontface = parameters.fontface || 'Arial';
            const fontsize = parameters.fontsize || 20;
            const borderThickness = parameters.borderThickness || 0;
            const borderColor = parameters.borderColor || { r:0, g:0, b:0, a:0.0 };
            const backgroundColor = parameters.backgroundColor || { r:0, g:0, b:0, a:0.5 };
            const textColor = parameters.textColor || { r:255, g:255, b:255, a:1.0 };
            const padding = parameters.padding || 8; 
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            context.font = `Bold ${fontsize}px ${fontface}`;
            const metrics = context.measureText(message);
            const textWidth = metrics.width;
            canvas.width = textWidth + padding * 2 + borderThickness * 2;
            canvas.height = fontsize * 1.4 + padding * 2 + borderThickness * 2; 
            context.font = `Bold ${fontsize}px ${fontface}`; 
            context.fillStyle = `rgba(${backgroundColor.r},${backgroundColor.g},${backgroundColor.b},${backgroundColor.a})`;
            context.strokeStyle = `rgba(${borderColor.r},${borderColor.g},${borderColor.b},${borderColor.a})`;
            context.lineWidth = borderThickness;
            const radius = 6; 
            context.beginPath();
            context.moveTo(radius + borderThickness, borderThickness);
            context.lineTo(canvas.width - radius - borderThickness, borderThickness);
            context.quadraticCurveTo(canvas.width - borderThickness, borderThickness, canvas.width - borderThickness, radius + borderThickness);
            context.lineTo(canvas.width - borderThickness, canvas.height - radius - borderThickness);
            context.quadraticCurveTo(canvas.width - borderThickness, canvas.height - borderThickness, canvas.width - radius - borderThickness, canvas.height - borderThickness);
            context.lineTo(radius + borderThickness, canvas.height - borderThickness);
            context.quadraticCurveTo(borderThickness, canvas.height - borderThickness, borderThickness, canvas.height - radius - borderThickness);
            context.lineTo(borderThickness, radius + borderThickness);
            context.quadraticCurveTo(borderThickness, borderThickness, radius + borderThickness, borderThickness);
            context.closePath();
            context.fill();
            if (borderThickness > 0) context.stroke();
            context.fillStyle = `rgba(${textColor.r},${textColor.g},${textColor.b},${textColor.a})`;
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(message, canvas.width / 2, canvas.height / 2);
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture, depthTest: false, transparent: backgroundColor.a < 1.0 || textColor.a < 1.0 });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(canvas.width / (fontsize * 5) , canvas.height / (fontsize * 5), 1.0); 
            return sprite;
        }

        function onPointerDown(event) {
            if (!renderer.xr.isPresenting || !domeGroup ) return;
            if (event.pointerType === 'mouse' && event.button !== 0) return;
            const clickX = (event.clientX / window.innerWidth) * 2 - 1;
            const clickY = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera({x: clickX, y: clickY}, camera);
            const intersects = raycaster.intersectObject(domeGroup, true);
            if (intersects.length > 0) {
                const firstIntersected = intersects[0].object;
                if (firstIntersected.userData.isDomePart || domeGroup.children.includes(firstIntersected)) { 
                    isDraggingDome = true;
                    activePointerId = event.pointerId;
                    renderer.domElement.setPointerCapture(event.pointerId);
                    showStatus("돔 이동 중... 기기 중앙을 원하는 위치로 조준하며 드래그.", 0);
                    allowReticleUpdate = true; 
                }
            }
        }
        function onPointerMove(event) { if (!isDraggingDome || event.pointerId !== activePointerId) return; }
        function onPointerUp(event) {
            if (event.pointerId !== activePointerId) return;
            if (isDraggingDome) {
                isDraggingDome = false;
                activePointerId = null;
                renderer.domElement.releasePointerCapture(event.pointerId);
                showStatus("돔 이동 완료.", 2000);
                allowReticleUpdate = false; 
                reticle.visible = false;
            }
        }
        
        function openSettingsModal() {
            document.getElementById('modalDomeType').value = domeType;
            document.getElementById('modalTargetSize').value = targetSize;
            document.getElementById('modalRadiusMultiplier').value = radiusMultiplier;
            document.getElementById('modalAzimuths').value = azimuths.join(',');
            document.getElementById('modalElevations').value = elevations.join(',');
            updateDomeTypeUI(domeType, 'modal-');
            settingsModal.style.display = 'block';
        }
        function closeSettingsModal() { settingsModal.style.display = 'none'; }
        function applySettingsFromModal() {
            domeType = document.getElementById('modalDomeType').value;
            targetSize = parseFloat(document.getElementById('modalTargetSize').value) || 100;
            radiusMultiplier = parseFloat(document.getElementById('modalRadiusMultiplier').value) || 3;
            azimuths = document.getElementById('modalAzimuths').value.split(',').map(Number).filter(n => !isNaN(n));
            elevations = document.getElementById('modalElevations').value.split(',').map(Number).filter(n => !isNaN(n));
            
            document.getElementById('domeType').value = domeType;
            document.getElementById('targetSize').value = targetSize;
            document.getElementById('radiusMultiplier').value = radiusMultiplier;
            document.getElementById('azimuths').value = azimuths.join(',');
            document.getElementById('elevations').value = elevations.join(',');
            updateDomeTypeUI(domeType);
            closeSettingsModal();
            showStatus("설정 적용됨.",2500);
            if(renderer.xr.isPresenting&&domeGroup){updateAndPlaceDome();}
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            renderer.setAnimationLoop(render);
        }

        const screenCenter = new THREE.Vector2(0, 0);
        const targetScreenPos = new THREE.Vector2();

        function render(timestamp, frame) {
            if (!frame) {
                renderer.render(scene, camera);
                return;
            }
            
            const referenceSpace = renderer.xr.getReferenceSpace();
            if (!referenceSpace) return;
            
            if (placementRequested) {
                placementRequested = false; 
                if (hitTestSource && reticle.visible) { 
                    const hitTestResults = frame.getHitTestResults(hitTestSource); 
                    if (hitTestResults.length > 0) {
                        const hit = hitTestResults[0];
                        const hitPose = hit.getPose(referenceSpace);
                        if (hitPose) {
                            const hitMatrix = new THREE.Matrix4().fromArray(hitPose.transform.matrix);
                            hitMatrix.userData = { hitTestResult: hit }; 
                            updateAndPlaceDome(hitMatrix, frame); 
                        }
                    }
                }
            }

            if (hitTestSource && allowReticleUpdate) {
                const hitTestResults = frame.getHitTestResults(hitTestSource);
                if (hitTestResults.length > 0) {
                    const hitPose = hitTestResults[0].getPose(referenceSpace);
                    if (hitPose) {
                        reticle.visible = true;
                        reticle.matrix.fromArray(hitPose.transform.matrix);
                    }
                } else {
                    reticle.visible = false;
                }
            } else if (!allowReticleUpdate) {
                reticle.visible = false; 
            }
            
            if (domeGroup && domeGroup.userData.anchor && !isDraggingDome) {
                const pose = frame.getPose(domeGroup.userData.anchor.anchorSpace, referenceSpace);
                if (pose) {
                    domeGroup.position.copy(pose.transform.position);
                    domeGroup.quaternion.copy(pose.transform.orientation);
                }
            }

            if (isDraggingDome && domeGroup && reticle.visible) {
                domeGroup.position.setFromMatrixPosition(reticle.matrix);
                domeGroup.quaternion.setFromRotationMatrix(reticle.matrix); 
            }

            if (domeCenterTarget) {
                const targetWorldPos = new THREE.Vector3();
                domeCenterTarget.getWorldPosition(targetWorldPos);
                const projectedPos = targetWorldPos.clone().project(camera);
                targetScreenPos.set(projectedPos.x, projectedPos.y);

                if (projectedPos.z < 1) {
                     const distance = screenCenter.distanceTo(targetScreenPos);
                     const alignmentThreshold = 0.05; 
                     if (distance < alignmentThreshold) {
                        crosshairEl.classList.add('aligned');
                     } else {
                        crosshairEl.classList.remove('aligned');
                     }
                } else {
                    crosshairEl.classList.remove('aligned');
                }
            } else {
                 crosshairEl.classList.remove('aligned');
            }
            
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>


 <!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>WebXR RTI Dome (v3 Stable - Torch Debug)</title>
    <style>
        body { 
            margin: 0; 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; 
            overflow: hidden; 
            background-color: #000; 
            color: #fff; 
            overscroll-behavior: none;
        }
        #inputContainer {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(20,20,20,0.85);
            padding: 15px;
            border-radius: 12px;
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 12px;
            max-width: calc(100% - 40px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.1);
        }
        #inputContainer label, #settingsModal label {
            font-size: 0.9em;
            color: #ccc;
            margin-bottom: 3px;
            display: block;
        }
        #inputContainer input[type="number"], 
        #inputContainer input[type="text"],
        #settingsModal input[type="number"], 
        #settingsModal input[type="text"] {
            width: calc(100% - 18px); 
            padding: 10px; 
            border-radius: 6px; 
            border: 1px solid #444; 
            background: #2a2a2a;
            color: #fff;
            font-size: 0.95em;
            box-sizing: border-box;
            margin-bottom: 8px;
        }
        #inputContainer input:focus, #settingsModal input:focus {
            outline: none;
            border-color: #007bff;
            box-shadow: 0 0 0 2px rgba(0,123,255,0.25);
        }
        #inputContainer button, #arModeControls button, #settingsModal button {
            padding: 12px 15px; 
            background-color: #007bff; 
            color: white;
            border: none; 
            border-radius: 6px; 
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.2s ease;
        }
        #inputContainer button:hover, #arModeControls button:hover, #settingsModal button:hover {
            background-color: #0056b3;
        }
        #arButton {
            position: absolute !important; 
            bottom: 20px !important;
            left: 50% !important;
            transform: translateX(-50%) !important;
            padding: 12px 20px !important;
            background-color: #28a745 !important;
            color: white !important;
            border: none !important;
            border-radius: 8px !important;
            font-size: 1.1em !important;
            z-index: 100 !important;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3) !important;
        }
        #statusMessage {
            position: absolute;
            bottom: 80px; 
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.75);
            padding: 10px 15px;
            border-radius: 8px;
            color: white;
            z-index: 10;
            text-align: center;
            font-size: 0.9em;
            display: none; 
            max-width: 80%;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        #arModeControls {
            display: none; /* Initially hidden */
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 20;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        #arModeControls button {
            background-color: #17a2b8; 
            font-size: 0.9em;
        }
        #arModeControls button#resetDomePositionButton { 
            background-color: #ffc107; 
            color: #212529;
        }
        #arModeControls button#resetDomePositionButton:hover {
             background-color: #e0a800;
        }
        #arModeControls button:hover {
            background-color: #117a8b;
        }
        #settingsModal {
            display: none; 
            position: fixed;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            background: rgba(30,30,30,0.97);
            padding: 25px;
            border-radius: 15px;
            z-index: 101; 
            width: 90%;
            max-width: 380px;
            box-shadow: 0 8px 30px rgba(0,0,0,0.6);
            border: 1px solid rgba(255,255,255,0.15);
        }
        #settingsModal h3 {
            margin-top: 0;
            margin-bottom: 20px;
            color: #00aeff;
            text-align: center;
            font-size: 1.3em;
        }
        #settingsModal .modal-actions {
            display: flex;
            justify-content: space-around;
            margin-top: 25px;
        }
         #settingsModal .modal-actions button {
            width: 45%;
         }
         #settingsModal #applyModalSettingsButton {
            background-color: #28a745; 
         }
         #settingsModal #applyModalSettingsButton:hover {
            background-color: #1e7e34; 
         }
         #settingsModal #closeModalButton {
            background-color: #dc3545; 
         }
         #settingsModal #closeModalButton:hover {
            background-color: #b02a37;
         }
    </style>
</head>
<body>
    <div id="inputContainer">
        <div>
            <label for="targetSize">대상 실제 크기 (mm):</label>
            <input type="number" id="targetSize" value="100">
        </div>
        <div>
            <label for="radiusMultiplier">돔 반지름 배율 (대상 크기의 N배, 2-4):</label>
            <input type="number" id="radiusMultiplier" value="3" min="2" max="4" step="0.1">
        </div>
        <div>
            <label for="azimuths">방위각 리스트 (°): (예: 0,45,90)</label>
            <input type="text" id="azimuths" value="0,45,90,135,180,225,270,315">
        </div>
        <div>
            <label for="elevations">고도각 리스트 (°): (예: 15,30,45)</label>
            <input type="text" id="elevations" value="15,30,45,60,75">
        </div>
        <button id="generateDomeButton">돔 생성/업데이트 (AR 시작 후)</button>
    </div>

    <div id="arModeControls">
        <button id="arSettingsButton">입력값</button>
        <button id="resetDomePositionButton">돔 위치 재설정</button>
        <button id="torchButton">손전등 켜기</button>
    </div>

    <div id="settingsModal">
        <h3>AR 설정</h3>
        <div>
            <label for="modalTargetSize">대상 실제 크기 (mm):</label>
            <input type="number" id="modalTargetSize">
        </div>
        <div>
            <label for="modalRadiusMultiplier">돔 반지름 배율 (2-4):</label>
            <input type="number" id="modalRadiusMultiplier" min="2" max="4" step="0.1">
        </div>
        <div>
            <label for="modalAzimuths">방위각 리스트 (°):</label>
            <input type="text" id="modalAzimuths">
        </div>
        <div>
            <label for="modalElevations">고도각 리스트 (°):</label>
            <input type="text" id="modalElevations">
        </div>
        <div class="modal-actions">
            <button id="applyModalSettingsButton">적용</button>
            <button id="closeModalButton">닫기</button>
        </div>
    </div>

    <div id="statusMessage"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { ARButton } from 'three/addons/webxr/ARButton.js';

        let camera, scene, renderer;
        let controller;
        let reticle; 
        let domeGroup = null; 
        let hitTestSource = null;
        
        let targetSize = 100; 
        let radiusMultiplier = 3;
        let azimuths = [0, 45, 90, 135, 180, 225, 270, 315];
        let elevations = [15, 30, 45, 60, 75];

        const raycaster = new THREE.Raycaster();
        const statusMessageEl = document.getElementById('statusMessage'); 
        const inputContainer = document.getElementById('inputContainer');
        const arModeControls = document.getElementById('arModeControls');
        const settingsModal = document.getElementById('settingsModal');
        const torchButton = document.getElementById('torchButton');
        const resetDomePositionButton = document.getElementById('resetDomePositionButton');

        let placementRequested = false;
        let allowReticleUpdate = true; 

        let isDraggingDome = false;
        let activePointerId = null; 
        let currentStream = null; 
        let isTorchOn = false;

        function showStatus(message, duration = 3000) {
            if (statusMessageEl) { 
                statusMessageEl.textContent = message;
                statusMessageEl.style.display = 'block';
                if (statusMessageEl.timeoutId) clearTimeout(statusMessageEl.timeoutId);
                if (duration > 0) {
                    statusMessageEl.timeoutId = setTimeout(() => {
                        statusMessageEl.style.display = 'none';
                    }, duration);
                }
            } else {
                console.warn("statusMessage element not found. Message:", message);
            }
        }

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.add(new THREE.AmbientLight(0x888888,1.2));
            const directionalLight = new THREE.DirectionalLight(0xffffff, 2.8);
            directionalLight.position.set(0.5, 1, 0.75).normalize();
            scene.add(directionalLight);

            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 40);

            reticle = new THREE.Mesh(
                new THREE.RingGeometry(0.03, 0.04, 32), 
                new THREE.MeshBasicMaterial({ color: 0xffffff, opacity: 0.9, transparent: true, depthTest: false, side: THREE.DoubleSide })
            );
            reticle.matrixAutoUpdate = false;
            reticle.visible = false;
            scene.add(reticle);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);

            const arButtonElement = ARButton.createButton(renderer, {
                requiredFeatures: ['hit-test', 'dom-overlay'], 
                optionalFeatures: ['anchors', 'plane-detection'], 
                domOverlay: { root: document.body } 
            });
            document.body.appendChild(arButtonElement);
            arButtonElement.id = 'arButton';
            arButtonElement.style.display = 'block';

            controller = renderer.xr.getController(0);
            controller.addEventListener('selectstart', onSelectStart);
            scene.add(controller);

            document.getElementById('targetSize').addEventListener('input', (e) => targetSize = parseFloat(e.target.value) || 100);
            document.getElementById('radiusMultiplier').addEventListener('input', (e) => radiusMultiplier = parseFloat(e.target.value) || 3);
            document.getElementById('azimuths').addEventListener('input', (e) => azimuths = e.target.value.split(',').map(Number).filter(n => !isNaN(n)));
            document.getElementById('elevations').addEventListener('input', (e) => elevations = e.target.value.split(',').map(Number).filter(n => !isNaN(n)));
            
            document.getElementById('generateDomeButton').addEventListener('click', () => {
                if (!renderer.xr.isPresenting) {
                    showStatus("AR 세션을 먼저 시작해주세요.", 3000);
                    return;
                }
                if (domeGroup) { 
                    updateAndPlaceDome();
                } else { 
                    allowReticleUpdate = true;
                    showStatus("돔을 배치할 위치를 탭하세요.", 3000);
                }
            });
            
            resetDomePositionButton.addEventListener('click', () => {
                if (renderer.xr.isPresenting) {
                    allowReticleUpdate = true; 
                    reticle.visible = true; 
                    placementRequested = false; 
                    showStatus("돔을 새로 배치할 위치를 탭하세요.", 3000);
                }
            });

            document.getElementById('arSettingsButton').addEventListener('click', openSettingsModal);
            torchButton.addEventListener('click', toggleTorch);
            document.getElementById('applyModalSettingsButton').addEventListener('click', applySettingsFromModal);
            document.getElementById('closeModalButton').addEventListener('click', closeSettingsModal);
            
            targetSize = parseFloat(document.getElementById('targetSize').value);
            radiusMultiplier = parseFloat(document.getElementById('radiusMultiplier').value);
            azimuths = document.getElementById('azimuths').value.split(',').map(Number).filter(n => !isNaN(n));
            elevations = document.getElementById('elevations').value.split(',').map(Number).filter(n => !isNaN(n));

            renderer.domElement.addEventListener('pointerdown', onPointerDown, false);
            renderer.domElement.addEventListener('pointermove', onPointerMove, false);
            renderer.domElement.addEventListener('pointerup', onPointerUp, false);
            renderer.domElement.addEventListener('pointercancel', onPointerUp, false);
            
            window.addEventListener('resize', onWindowResize);

            renderer.xr.addEventListener('sessionstart', async () => {
                const session = renderer.xr.getSession();
                showStatus("AR 세션 시작됨. 표면을 찾아 레티클을 조준하고 탭하여 돔 배치.", 0); 
                inputContainer.style.display = 'none';
                arModeControls.style.display = 'flex';
                allowReticleUpdate = true; 

                try {
                    const viewerReferenceSpace = await session.requestReferenceSpace('viewer');
                    hitTestSource = await session.requestHitTestSource({ 
                        space: viewerReferenceSpace,
                    });
                    if (!hitTestSource) {
                        showStatus("표면 감지 기능(Hit-test)을 시작할 수 없습니다.", 4000);
                    }
                } catch (error) {
                    console.error("Hit-test source 요청 실패:", error);
                    showStatus("Hit-test를 시작할 수 없습니다. AR 기능이 제한될 수 있습니다.", 4000);
                }
            });

            renderer.xr.addEventListener('sessionend', () => {
                hitTestSource = null;
                reticle.visible = false;
                allowReticleUpdate = true; 
                clearDomeAndChildren();
                showStatus("AR 세션 종료됨.", 3000);
                inputContainer.style.display = 'flex';
                arModeControls.style.display = 'none';
                closeSettingsModal();
                
                if (isTorchOn) { 
                    controlTorch(false); 
                } else if (currentStream) { 
                    currentStream.getTracks().forEach(track => {
                        if (track.readyState === 'live') track.stop();
                    });
                    currentStream = null;
                }
                isTorchOn = false; 
                torchButton.textContent = "손전등 켜기";
            });
            showStatus("AR 세션을 시작하고, 바닥이나 벽을 탭하여 돔을 배치하세요.", 5000); 
        }
        
        function updateAndPlaceDome(hitMatrix = null, frameForAnchor = null) {
            if (domeGroup && !hitMatrix) { 
                const oldAnchor = domeGroup.userData.anchor;
                const oldPosition = domeGroup.position.clone();
                const oldQuaternion = domeGroup.quaternion.clone();
                clearDomeAndChildren();
                domeGroup = createDome();
                if (oldAnchor) {
                    domeGroup.userData.anchor = oldAnchor; 
                } else {
                    domeGroup.position.copy(oldPosition);
                    domeGroup.quaternion.copy(oldQuaternion);
                }
                scene.add(domeGroup);
                showStatus("돔 설정 업데이트 완료.", 2000);
                allowReticleUpdate = false; 
                reticle.visible = false;
            } else if (hitMatrix) { 
                clearDomeAndChildren();
                domeGroup = createDome();
                
                const referenceSpace = renderer.xr.getReferenceSpace();
                if (frameForAnchor && referenceSpace && hitMatrix.userData?.hitTestResult) {
                    const hit = hitMatrix.userData.hitTestResult;
                    hit.createAnchor().then(anchor => {
                        domeGroup.userData.anchor = anchor;
                        scene.add(domeGroup);
                        showStatus("돔 배치 완료 (앵커 사용).", 3000);
                        allowReticleUpdate = false; 
                        reticle.visible = false;
                    }).catch(err => {
                        console.warn("앵커 생성 실패:", err);
                        domeGroup.position.setFromMatrixPosition(hitMatrix);
                        domeGroup.quaternion.setFromRotationMatrix(hitMatrix);
                        scene.add(domeGroup);
                        showStatus("돔 배치 완료 (앵커 실패, 직접 배치).", 3000);
                        allowReticleUpdate = false; 
                        reticle.visible = false;
                    });
                } else { 
                    domeGroup.position.setFromMatrixPosition(hitMatrix);
                    domeGroup.quaternion.setFromRotationMatrix(hitMatrix);
                    scene.add(domeGroup);
                    showStatus("돔 배치 완료 (앵커 정보 없음).", 3000);
                    allowReticleUpdate = false; 
                    reticle.visible = false;
                }
            } else if (!domeGroup) { 
                showStatus("돔을 배치할 위치를 탭하세요.", 3000);
                allowReticleUpdate = true; 
            }
        }
        
        function clearDomeAndChildren() {
            if (!domeGroup) return;
            domeGroup.traverse(child => {
                if (child.isMesh) {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(m => { if (m.map) m.map.dispose(); m.dispose(); });
                        } else {
                            if (child.material.map) child.material.map.dispose(); child.material.dispose();
                        }
                    }
                }
                if (child.isSprite && child.material) {
                     if (child.material.map) child.material.map.dispose(); child.material.dispose();
                }
            });
            scene.remove(domeGroup);
            domeGroup = null;
        }

        function createDome() {
            const newDomeGroup = new THREE.Group();
            const actualRadius = Math.max(0.01, (targetSize * radiusMultiplier) / 1000); 

            const domeGeometry = new THREE.SphereGeometry(actualRadius, 32, 16, 0, Math.PI * 2, 0, Math.PI / 2);
            const domeMaterial = new THREE.MeshStandardMaterial({
                color: 0x101010, transparent: true, opacity: 0.65, side: THREE.DoubleSide,
                metalness: 0.1, roughness: 0.9,
            });
            const hemisphere = new THREE.Mesh(domeGeometry, domeMaterial);
            hemisphere.userData.isDomePart = true; 
            newDomeGroup.add(hemisphere);

            const targetMarkerRadius = actualRadius * 0.05;
            const targetMarkerGeometry = new THREE.CircleGeometry(targetMarkerRadius, 32);
            const targetMarkerMaterial = new THREE.MeshBasicMaterial({ color: 0x888888, side: THREE.DoubleSide, transparent: true, opacity: 0.7 });
            const targetMarker = new THREE.Mesh(targetMarkerGeometry, targetMarkerMaterial);
            targetMarker.rotation.x = -Math.PI / 2; 
            targetMarker.position.y = 0.001; 
            newDomeGroup.add(targetMarker);

            const markerRadius = Math.max(0.003, actualRadius * 0.025); 
            const markerGeometry = new THREE.SphereGeometry(markerRadius, 12, 6);
            const markerMaterial = new THREE.MeshStandardMaterial({ color: 0xFFD700, metalness: 0.3, roughness: 0.4 });
            
            let markerCount = 0;
            (elevations || []).forEach(el => {
                (azimuths || []).forEach(az => {
                    if (isNaN(el) || isNaN(az)) return;
                    markerCount++;
                    const elRad = THREE.MathUtils.degToRad(el);
                    const azRad = THREE.MathUtils.degToRad(az);
                    const x = actualRadius * Math.cos(elRad) * Math.cos(azRad);
                    const y = actualRadius * Math.sin(elRad); 
                    const z = actualRadius * Math.cos(elRad) * Math.sin(azRad);

                    const marker = new THREE.Mesh(markerGeometry, markerMaterial.clone());
                    marker.position.set(x, y, z);
                    marker.userData = { 
                        isLightMarker: true, 
                        azimuth: az, 
                        elevation: el, 
                        labelMesh: null, 
                        isLabelVisible: false,
                        number: markerCount 
                    };
                    newDomeGroup.add(marker);
                });
            });
            newDomeGroup.userData.isDomeRoot = true;
            newDomeGroup.userData.anchor = null; 
            return newDomeGroup;
        }

        function onSelectStart(event) {
            if (domeGroup) {
                const controller = event.target; 
                const tempMatrix = new THREE.Matrix4();
                tempMatrix.identity().extractRotation(controller.matrixWorld); 
                raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld); 
                raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix); 

                const intersects = raycaster.intersectObject(domeGroup, true);
                if (intersects.length > 0) {
                    const firstIntersected = intersects[0].object;
                    if (firstIntersected.userData.isLightMarker) {
                        toggleMarkerLabel(firstIntersected);
                        return; 
                    }
                }
            }

            if (reticle.visible && allowReticleUpdate) { 
                placementRequested = true;
            } else if (!allowReticleUpdate && domeGroup) {
                showStatus("돔 위치를 변경하려면 '돔 위치 재설정' 버튼을 누르세요.", 2500);
            } else {
                 showStatus("레티클이 표면을 찾지 못했습니다. 다른 곳을 조준하세요.", 2500);
            }
        }
        
        function toggleMarkerLabel(marker) {
            marker.userData.isLabelVisible = !marker.userData.isLabelVisible;
            if (marker.userData.isLabelVisible) {
                if (!marker.userData.labelMesh) {
                    const labelText = `${marker.userData.number}`; 
                    marker.userData.labelMesh = createTextSprite(labelText, { 
                        fontsize: 32, 
                        fontface: "Arial", 
                        textColor: { r:255, g:255, b:255, a:1.0 },
                        backgroundColor: { r:30, g:30, b:30, a:0.8 }
                    });
                    
                    const domeRadius = domeGroup.children.find(c => c.userData.isDomePart)?.geometry.parameters.radius || 1;
                    const labelScaleFactor = domeRadius * 0.05; 
                    marker.userData.labelMesh.scale.set(labelScaleFactor, labelScaleFactor, labelScaleFactor); 

                    const offsetDirection = marker.position.clone().normalize();
                    const offsetDistance = marker.geometry.parameters.radius * 2.5;
                    const labelPosition = marker.position.clone().add(offsetDirection.multiplyScalar(offsetDistance));
                    marker.userData.labelMesh.position.copy(labelPosition);
                    
                    domeGroup.add(marker.userData.labelMesh); 
                }
                marker.userData.labelMesh.visible = true;
            } else {
                if (marker.userData.labelMesh) {
                    marker.userData.labelMesh.visible = false;
                }
            }
        }

        function createTextSprite(message, parameters = {}) {
            const fontface = parameters.fontface || 'Arial';
            const fontsize = parameters.fontsize || 20;
            const borderThickness = parameters.borderThickness || 0;
            const borderColor = parameters.borderColor || { r:0, g:0, b:0, a:0.0 };
            const backgroundColor = parameters.backgroundColor || { r:0, g:0, b:0, a:0.5 };
            const textColor = parameters.textColor || { r:255, g:255, b:255, a:1.0 };
            const padding = parameters.padding || 10;
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            context.font = `Bold ${fontsize}px ${fontface}`;
            const metrics = context.measureText(message);
            const textWidth = metrics.width;
            canvas.width = textWidth + padding * 2 + borderThickness * 2;
            canvas.height = fontsize * 1.4 + padding * 2 + borderThickness * 2; 
            context.font = `Bold ${fontsize}px ${fontface}`; 
            context.fillStyle = `rgba(${backgroundColor.r},${backgroundColor.g},${backgroundColor.b},${backgroundColor.a})`;
            context.strokeStyle = `rgba(${borderColor.r},${borderColor.g},${borderColor.b},${borderColor.a})`;
            context.lineWidth = borderThickness;
            const radius = 8; 
            context.beginPath();
            context.moveTo(radius + borderThickness, borderThickness);
            context.lineTo(canvas.width - radius - borderThickness, borderThickness);
            context.quadraticCurveTo(canvas.width - borderThickness, borderThickness, canvas.width - borderThickness, radius + borderThickness);
            context.lineTo(canvas.width - borderThickness, canvas.height - radius - borderThickness);
            context.quadraticCurveTo(canvas.width - borderThickness, canvas.height - borderThickness, canvas.width - radius - borderThickness, canvas.height - borderThickness);
            context.lineTo(radius + borderThickness, canvas.height - borderThickness);
            context.quadraticCurveTo(borderThickness, canvas.height - borderThickness, borderThickness, canvas.height - radius - borderThickness);
            context.lineTo(borderThickness, radius + borderThickness);
            context.quadraticCurveTo(borderThickness, borderThickness, radius + borderThickness, borderThickness);
            context.closePath();
            context.fill();
            if (borderThickness > 0) context.stroke();
            context.fillStyle = `rgba(${textColor.r},${textColor.g},${textColor.b},${textColor.a})`;
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(message, canvas.width / 2, canvas.height / 2);
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture, depthTest: false });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.scale.set(canvas.width / 100, canvas.height / 100, 1.0); 
            return sprite;
        }

        function onPointerDown(event) {
            if (!renderer.xr.isPresenting || !domeGroup ) return;
            if (event.pointerType === 'mouse' && event.button !== 0) return;

            const clickX = (event.clientX / window.innerWidth) * 2 - 1;
            const clickY = -(event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera({x: clickX, y: clickY}, camera);

            const intersects = raycaster.intersectObject(domeGroup, true);
            if (intersects.length > 0) {
                const firstIntersected = intersects[0].object;
                if (firstIntersected.userData.isDomePart || domeGroup.children.includes(firstIntersected)) { 
                    isDraggingDome = true;
                    activePointerId = event.pointerId;
                    renderer.domElement.setPointerCapture(event.pointerId);
                    showStatus("돔 이동 중... 기기 중앙을 원하는 위치로 조준하며 드래그.", 0);
                    allowReticleUpdate = true; 
                }
            }
        }
        function onPointerMove(event) { if (!isDraggingDome || event.pointerId !== activePointerId) return; }
        function onPointerUp(event) {
            if (event.pointerId !== activePointerId) return;
            if (isDraggingDome) {
                isDraggingDome = false;
                activePointerId = null;
                renderer.domElement.releasePointerCapture(event.pointerId);
                showStatus("돔 이동 완료.", 2000);
                if (domeGroup && domeGroup.userData.anchor) {
                    // Option: Detach from anchor after drag if desired
                    // domeGroup.userData.anchor = null; 
                }
                allowReticleUpdate = false; 
                reticle.visible = false;
            }
        }
        
        function openSettingsModal(){document.getElementById('modalTargetSize').value=targetSize;document.getElementById('modalRadiusMultiplier').value=radiusMultiplier;document.getElementById('modalAzimuths').value=azimuths.join(',');document.getElementById('modalElevations').value=elevations.join(',');settingsModal.style.display='block';}
        function closeSettingsModal(){settingsModal.style.display='none';}
        function applySettingsFromModal(){targetSize=parseFloat(document.getElementById('modalTargetSize').value)||100;radiusMultiplier=parseFloat(document.getElementById('modalRadiusMultiplier').value)||3;azimuths=document.getElementById('modalAzimuths').value.split(',').map(Number).filter(n=>!isNaN(n));elevations=document.getElementById('modalElevations').value.split(',').map(Number).filter(n=>!isNaN(n));document.getElementById('targetSize').value=targetSize;document.getElementById('radiusMultiplier').value=radiusMultiplier;document.getElementById('azimuths').value=azimuths.join(',');document.getElementById('elevations').value=elevations.join(',');closeSettingsModal();showStatus("설정 적용됨.",2500);if(renderer.xr.isPresenting&&domeGroup){updateAndPlaceDome();}}
        
        async function controlTorch(enable) {
            console.log(`controlTorch 호출됨 - enable: ${enable}, 현재 스트림: ${currentStream ? '있음' : '없음'}, 현재 손전등 상태: ${isTorchOn}`);

            if (enable && !currentStream) { 
                 try {
                    console.log("손전등을 켜기 위해 카메라 스트림을 요청합니다...");
                    currentStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } });
                    console.log("카메라 스트림 확보 성공.");
                 } catch(err) {
                    console.error("getUserMedia 실패 (손전등용):", err.name, err.message);
                    showStatus("손전등 제어 불가: 카메라 접근 실패 - " + err.name, 3000);
                    currentStream = null; 
                    return false; 
                 }
            } else if (!currentStream && !enable) { 
                console.log("손전등 제어: 끄기 요청, 하지만 스트림 없음 (이미 꺼져있거나 확보 안됨).");
                isTorchOn = false;
                torchButton.textContent = "손전등 켜기";
                return true; 
            } else if (!currentStream && enable) { 
                console.warn("손전등 제어: 켜기 요청, 하지만 스트림이 예기치 않게 null입니다.");
                showStatus("손전등 오류: 카메라 스트림 없음", 2500);
                return false;
            }

            if (!currentStream) { 
                console.error("손전등 제어: 치명적 오류 - currentStream이 null입니다.");
                showStatus("손전등 시스템 오류", 2500);
                return false;
            }

            const videoTracks = currentStream.getVideoTracks();
            if (!videoTracks || videoTracks.length === 0) {
                showStatus("손전등 제어 불가: 비디오 트랙 없음", 2500);
                console.warn("손전등 제어: 스트림에서 비디오 트랙을 찾을 수 없습니다.");
                 if (!enable) { 
                    currentStream.getTracks().forEach(track => { if (track.readyState === 'live') track.stop(); });
                    currentStream = null;
                    console.log("비디오 트랙이 없어 손전등을 끄면서 스트림을 정리했습니다.");
                    isTorchOn = false;
                    torchButton.textContent = "손전등 켜기";
                }
                return false;
            }
            const videoTrack = videoTracks[0];

            const capabilities = videoTrack.getCapabilities ? videoTrack.getCapabilities() : {};
            console.log("비디오 트랙 기능:", JSON.stringify(capabilities));

            if (!capabilities.torch) {
                showStatus("이 기기/브라우저에서는 손전등 기능을 지원하지 않습니다.", 3000);
                console.warn("손전등 제어: 비디오 트랙에서 torch 기능을 지원하지 않습니다.");
                currentStream.getTracks().forEach(track => { if (track.readyState === 'live') track.stop(); });
                currentStream = null;
                console.log("torch 기능 미지원으로 스트림을 정리했습니다.");
                isTorchOn = false; 
                torchButton.textContent = "손전등 켜기";
                return false;
            }

            try {
                console.log(`torch 제약 조건 적용 시도: ${enable}`);
                await videoTrack.applyConstraints({
                    advanced: [{ torch: enable }]
                });
                isTorchOn = enable;
                torchButton.textContent = enable ? "손전등 끄기" : "손전등 켜기";
                showStatus(enable ? "손전등 켜짐" : "손전등 꺼짐", 1500);
                console.log(`torch 제약 조건 적용 성공. isTorchOn: ${isTorchOn}`);

                if (!enable) { 
                    console.log("손전등을 끈 후 카메라 스트림을 해제합니다.");
                    currentStream.getTracks().forEach(track => {
                        if (track.readyState === 'live') track.stop();
                    });
                    currentStream = null;
                }
                return true;
            } catch (err) {
                console.error("applyConstraints 실패 (손전등용):", err.name, err.message);
                showStatus("손전등 제어 중 오류 발생: " + err.name, 3000);
                if (currentStream) {
                    currentStream.getTracks().forEach(track => { if (track.readyState === 'live') track.stop(); });
                    currentStream = null;
                    console.log("손전등 제어 실패 후 스트림을 정리했습니다.");
                }
                isTorchOn = false; 
                torchButton.textContent = "손전등 켜기";
                return false;
            }
        }
        async function toggleTorch(){await controlTorch(!isTorchOn);}

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            renderer.setAnimationLoop(render);
        }

        function render(timestamp, frame) {
            const session = renderer.xr.getSession();
            if (!session) {
                renderer.render(scene, camera);
                return;
            }
            
            if (frame) { 
                const referenceSpace = renderer.xr.getReferenceSpace();
                if (!referenceSpace) return;
                
                if (placementRequested) {
                    placementRequested = false; 
                    if (hitTestSource && reticle.visible) { 
                        const hitTestResults = frame.getHitTestResults(hitTestSource); 
                        if (hitTestResults.length > 0) {
                            const hit = hitTestResults[0];
                            const hitPose = hit.getPose(referenceSpace);
                            if (hitPose) {
                                const hitMatrix = new THREE.Matrix4().fromArray(hitPose.transform.matrix);
                                hitMatrix.userData = { hitTestResult: hit }; 
                                updateAndPlaceDome(hitMatrix, frame); 
                            }
                        } else {
                            showStatus("배치할 표면을 찾지 못했습니다 (재시도).", 2000);
                        }
                    } else if (!hitTestSource) {
                        showStatus("표면 감지 기능이 활성화되지 않았습니다.", 2000);
                    } else if (!reticle.visible) {
                        showStatus("표면을 먼저 조준하세요.", 2000);
                    }
                }

                if (hitTestSource && allowReticleUpdate) {
                    const hitTestResults = frame.getHitTestResults(hitTestSource);
                    if (hitTestResults.length > 0) {
                        const hitPose = hitTestResults[0].getPose(referenceSpace);
                        if (hitPose) {
                            reticle.visible = true;
                            reticle.matrix.fromArray(hitPose.transform.matrix);
                        }
                    } else {
                        reticle.visible = false;
                    }
                } else if (!allowReticleUpdate) {
                    reticle.visible = false; 
                }
                
                if (domeGroup && domeGroup.userData.anchor && !isDraggingDome) {
                    const pose = frame.getPose(domeGroup.userData.anchor.anchorSpace, referenceSpace);
                    if (pose) {
                        domeGroup.position.copy(pose.transform.position);
                        domeGroup.quaternion.copy(pose.transform.orientation);
                    }
                }

                if (isDraggingDome && domeGroup && reticle.visible) {
                    domeGroup.position.setFromMatrixPosition(reticle.matrix);
                    domeGroup.quaternion.setFromRotationMatrix(reticle.matrix); 
                }
            }
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>

<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>WebXR AR Dome Interactive v2</title>
  <style>
    body { margin:0; overflow:hidden; font-family:sans-serif; background:#111; color:#eee; }
    #ui {
      position:absolute; top:10px; left:10px;
      background:rgba(0,0,0,0.7); padding:12px; border-radius:8px;
      z-index:10; max-width:260px;
    }
    #ui label { display:block; font-size:13px; margin-top:8px; }
    #ui input, #ui select { width:100%; padding:4px; margin-top:4px; border-radius:4px; border:none; }
    button { margin-top:10px; width:100%; padding:8px; border:none; border-radius:4px; background:#28a745; color:#fff; font-weight:bold; cursor:pointer; }
    #flashBtn {
      position:absolute; top:10px; right:10px;
      background:#ffc107; color:#000; padding:8px; border:none; border-radius:6px;
      font-size:14px; cursor:pointer; z-index:10;
    }
    #crosshair {
      position:absolute; top:50%; left:50%; width:30px; height:30px;
      margin:-15px 0 0 -15px; border:2px solid #fff; border-radius:50%; pointer-events:none; z-index:9;
    }
  </style>
</head>
<body>
  <div id="ui">
    <label>대상 크기 (mm):<br><input type="number" id="targetSize" value="100"></label>
    <label>돔 배율:<br><select id="sizeMultiplier"><option value="2">2×</option><option value="3" selected>3×</option><option value="4">4×</option></select></label>
    <label>방위각 (°, 콤마):<br><input type="text" id="azimuths" value="0,90,180,270"></label>
    <label>고도각 (°, 콤마):<br><input type="text" id="elevations" value="30,45,60"></label>
    <button id="generate">돔 생성</button>
  </div>
  <button id="flashBtn" disabled>Flash OFF</button>
  <div id="crosshair"></div>

  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';
    import { ARButton } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/webxr/ARButton.js';
    import { TransformControls } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/TransformControls.js';

    let camera, scene, renderer, domeGroup, transformControls;
    let videoTrack = null, torchOn = false;
    const raycaster = new THREE.Raycaster();
    const pointer = new THREE.Vector2();

    init();

    function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 50);

      renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      document.body.appendChild(renderer.domElement);
      document.body.appendChild(ARButton.createButton(renderer));

      // ground plane for reticle intersection
      const ground = new THREE.Mesh(
        new THREE.PlaneGeometry(10,10),
        new THREE.MeshBasicMaterial({ visible:false })
      );
      ground.rotation.x = -Math.PI/2; ground.position.y = 0;
      scene.add(ground);

      // light
      const light = new THREE.DirectionalLight(0xffffff,1);
      light.position.set(5,10,7.5);
      scene.add(light);

      document.getElementById('generate').onclick = () => {
        const radius = getRadius();
        const azs = getArray('azimuths');
        const els = getArray('elevations');
        // reticle intersection point
        const cross = document.getElementById('crosshair');
        // cast ray at center
        raycaster.setFromCamera({x:0,y:0}, camera);
        const hits = raycaster.intersectObject(ground);
        if (hits.length>0) generateDome(radius, azs, els, hits[0].point);
      };
      document.getElementById('flashBtn').onclick = toggleFlash;

      tryFlashAccess();
      window.addEventListener('click', onSceneClick);
      window.addEventListener('resize', onResize);

      renderer.setAnimationLoop(() => renderer.render(scene,camera));
    }

    function getRadius(){
      const size = parseFloat(document.getElementById('targetSize').value);
      const mul = parseFloat(document.getElementById('sizeMultiplier').value);
      return (size*mul)/1000;
    }

    function getArray(id){return document.getElementById(id).value.split(',').map(n=>parseFloat(n.trim())).filter(n=>!isNaN(n));}

    function generateDome(radius, azimuths, elevations, pos){
      if (domeGroup) scene.remove(domeGroup);
      domeGroup = new THREE.Group();

      const domeMat = new THREE.MeshStandardMaterial({color:0x000000,transparent:true,opacity:0.3,side:THREE.DoubleSide});
      const domeMesh = new THREE.Mesh(new THREE.SphereGeometry(radius,32,16,0,Math.PI*2,0,Math.PI/2),domeMat);
      domeGroup.add(domeMesh);

      const geo = new THREE.SphereGeometry(0.03,12,12);
      const mat = new THREE.MeshBasicMaterial({color:0xffff00});
      azimuths.forEach(az=>elevations.forEach(el=>{
        const t = THREE.MathUtils.degToRad(az), p = THREE.MathUtils.degToRad(el);
        const x = radius*Math.cos(p)*Math.sin(t), y = radius*Math.sin(p), z = radius*Math.cos(p)*Math.cos(t);
        const m = new THREE.Mesh(geo,mat);
        m.position.set(x,y,z);
        m.userData.label = `${az}°, ${el}°`;
        domeGroup.add(m);
      }));

      domeGroup.position.copy(pos);
      scene.add(domeGroup);

      if (transformControls) scene.remove(transformControls);
      transformControls = new TransformControls(camera, renderer.domElement);
      transformControls.attach(domeGroup);
      transformControls.setMode('translate');
      scene.add(transformControls);
    }

    function onSceneClick(evt){
      pointer.x=(evt.clientX/window.innerWidth)*2-1;
      pointer.y=-(evt.clientY/window.innerHeight)*2+1;
      raycaster.setFromCamera(pointer,camera);
      const hits=raycaster.intersectObjects(scene.children,true);
      if (hits.length>0){
        const o=hits[0].object;
        if (o.userData.label){
          if (!o.userData.sprite){
            const sp=makeTextSprite(o.userData.label);
            sp.position.copy(o.position).add(new THREE.Vector3(0,0.05,0)); scene.add(sp); o.userData.sprite=sp;
          } else { scene.remove(o.userData.sprite); delete o.userData.sprite; }
        }
      }
    }

    function makeTextSprite(txt){
      const c=document.createElement('canvas'),cx=c.getContext('2d');
      cx.font='24px sans-serif'; c.width=cx.measureText(txt).width+20; c.height=32;
      cx.fillStyle='rgba(0,0,0,0.7)'; cx.fillRect(0,0,c.width,c.height);
      cx.fillStyle='white'; cx.fillText(txt,10,24);
      const tx=new THREE.CanvasTexture(c), sp=new THREE.Sprite(new THREE.SpriteMaterial({map:tx}));
      sp.scale.set(c.width/200,c.height/200,1); return sp;
    }

    async function tryFlashAccess(){
      try{
        const st=await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment'}});
        const tr=st.getVideoTracks()[0], caps=tr.getCapabilities();
        if (caps.torch){ videoTrack=tr; document.getElementById('flashBtn').disabled=false; }
      }catch{}
    }
    function toggleFlash(){ if (!videoTrack)return; torchOn=!torchOn;
      videoTrack.applyConstraints({advanced:[{torch:torchOn}]})
        .then(()=>document.getElementById('flashBtn').textContent=torchOn?'Flash ON':'Flash OFF');
    }
    function onResize(){renderer.setSize(window.innerWidth,window.innerHeight);camera.aspect=window.innerWidth/window.innerHeight;camera.updateProjectionMatrix();}
  </script>
</body>
</html>
